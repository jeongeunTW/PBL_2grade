$version 11.00

// This is the root component of the entire GUI application.
$rect <589,11,789,51>
$output false
class Application : Core::Root
{
  $rect <910,70,1090,110>
  inherited method Init()
  {
    //PresentDialog(new Application::MainView, null, null, null, null, null, null, null, null, false);
  }

  $rect <909,20,1109,60>
  inherited property Bounds = <0,0,800,450>;

  // To do:
  // 
  // - Adjust the visible size of your application (the thick blue border). It should \
  // correspond to the size of your target display.
  // 
  // - The simplest way to compose the appearance of the application is to use the \
  // 'Views' and 'Widgets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To store values use the 'Variable', 'Array' and 'Property' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  note legend Note1
  {
    attr Bounds = <9,540,789,770>;
  }

  $rect <20,20,160,60>
  object Application::MainView MainView
  {
    preset Bounds = <0,0,800,450>;
  }
}

$rect <1509,200,1749,240>
$output false
autoobject WidgetSet::PushButtonConfig PushButtonConfig
{
  preset LabelColorActive = #FFFFFFFF;
  preset LabelColorFocused = #FFFFFFFF;
  preset LabelColorDisabled = #FFFFFFFF;
  preset LabelColorDefault = #FFFFFFFF;
  preset LabelFont = Application::MyFont2;
}

$rect <1509,280,1709,320>
$output false
resource Resources::Bitmap BtnCircle
{
  attr bitmapfile FileName = .\Res\BtnCircle (3).png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1509,360,1709,400>
$output false
resource Resources::Bitmap BtnCapsule
{
  attr bitmapfile FileName = .\Res\btn1 (1).png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <589,91,789,131>
$output false
class MainView : Core::Group
{
  $rect <840,472,1040,512>
  inherited property Bounds = <0,0,800,450>;

  $rect <1070,472,1270,512>
  slot EnterQuickMenu
  {
    Application::Device.MainViewElement = false;
    Application::Device.Grid = false;
    PresentDialog( QuickMenu, Effects::SlideDownCentered, null, null, null, null, null, null, null, false );
  }

  $rect <20,20,160,60>
  object Views::Rectangle SDBackground
  {
    preset Bounds = <39,38,119,88>;
  }

  $rect <20,20,160,60>
  object Views::Border Battery
  {
    preset Bounds = <655,43,755,93>;
    preset Width = 4;
  }

  $rect <20,20,160,60>
  object Views::Image ModeIcon
  {
    preset StackingPriority = 3;
    preset Bounds = <292,345,367,417>;
    preset Quality = true;
    preset FrameNumber = 2;
    preset Bitmap = Application::SymbolIconsLarge;
    preset Embedded = false;
  }

  $rect <20,20,160,60>
  object Views::Text SD
  {
    preset Bounds = <39,44,119,83>;
    preset String = "SD";
    preset Font = Resources::FontLarge;
    preset Color = #000000FF;
  }

  $rect <840,810,1040,850>
  slot ElementVisiable_Slot
  {
    if(Application::Device.MainViewElement)
       Application::Device.MainViewElement = false;

    else
      Application::Device.MainViewElement = true;
  }

  $rect <1070,512,1270,552>
  slot EnterAlbum
  {
    Application::Device.MainViewElement = false;
    PresentDialog( AlbumView, Effects::SlideRightCentered, null, null, null, null, null, null, null, false );
  }

  $rect <1069,629,1269,669>
  slot EnterSetSpec
  {
    Application::Device.MainViewElement = false;
    switch(Application::Device.Mode){
      case 0:{
        PresentDialog( VideoSpec, Effects::SlideUpCentered, null, null, null, null, null, null, null, false );
        VideoSpec.HorizontalList.ScrollOffset = -150 * Application::Device.VideoResolution;
        VideoSpec.HorizontalList1.ScrollOffset = -150 * Application::Device.VideoFrameRate;
      }
      case 1:{
        PresentDialog( TLSpec, Effects::SlideUpCentered, null, null, null, null, null, null, null, false );
        TLSpec.HorizontalList.ScrollOffset = -150 * Application::Device.TLTime;
        TLSpec.HorizontalList1.ScrollOffset = -150 * Application::Device.TLDuration;
      }
      case 2:{
        PresentDialog( HLSpec, Effects::SlideUpCentered, null, null, null, null, null, null, null, false );
        HLSpec.HorizontalList.ScrollOffset = -150 * Application::Device.HLTime;
        HLSpec.HorizontalList1.ScrollOffset = -150 * Application::Device.HLDuration;
      }
      case 3:{
        PresentDialog( SMSpec, Effects::SlideUpCentered, null, null, null, null, null, null, null, false );
        SMSpec.HorizontalList.ScrollOffset = -150 * Application::Device.SMResolution;
        SMSpec.HorizontalList1.ScrollOffset = -150 * Application::Device.SMFrameRate;
      }
      case 4:{
        PresentDialog( BurstSpec, Effects::SlideUpCentered, null, null, null, null, null, null, null, false );
        BurstSpec.HorizontalList.ScrollOffset = -150 * Application::Device.BurstTimer;
      }
      case 5:{
        PresentDialog( PhotoSpec, Effects::SlideUpCentered, null, null, null, null, null, null, null, false );
        PhotoSpec.HorizontalList.ScrollOffset = -150 * Application::Device.PhotoTimer;
        PhotoSpec.HorizontalList1.ScrollOffset = -150 * Application::Device.PhotoResolution;
      }
      default: ;
    }


  }

  $rect <1070,552,1270,592>
  slot EnterSetParam
  {
    Application::Device.MainViewElement = false;
    PresentDialog( Parameter, Effects::SlideLeftCentered, null, null, null, null, null, null, null, false );
  }

  $rect <20,20,160,60>
  object Core::WipeTouchHandler WipeTouchHandler
  {
    preset Bounds = <0,0,800,450>;
    preset OnBottom = EnterQuickMenu;
    preset OnRight = EnterAlbum;
    preset OnTop = EnterSetSpec;
    preset OnLeft = EnterSetParam;
    preset RetargetCondition = Core::RetargetReason[ForeignPress];
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler
  {
    preset Bounds = <124,125,676,326>;
    preset OnSlide = SelectMode;
    preset RetargetCondition = Core::RetargetReason[ForeignPress];
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler ScreenTouchHandler
  {
    preset Point4 = <0,0>;
    preset Point3 = <800,0>;
    preset Point2 = <800,450>;
    preset Point1 = <0,450>;
    preset OnLeave = null;
    preset OnRelease = ElementVisiable_Slot;
    preset OnPress = null;
    preset RetargetDelay = 0;
    preset RetargetCondition = Core::RetargetReason[WipeDown, WipeLeft, WipeRight, WipeUp];
  }

  $rect <1069,589,1269,629>
  slot SelectMode
  {
    Application::Device.MainViewElement = false;
    PresentDialog( SwitchMode, null, null, null, null, null, null, null, null, false );
    SwitchMode.TouchTimer.Enabled = true;
    SwitchMode.HorizontalList.ScrollOffset = -160 * Application::Device.Mode;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Zoom
  {
    preset Bounds = <27,329,132,429>;
    preset Enabled = true;
    preset Icon = Application::BtnCircle;
    preset Label = "1x";
    preset Appearance = Application::PushButtonConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Setting
  {
    preset Bounds = <237,329,564,429>;
    preset OnLeave = EnterSetSpec;
    preset OnPress = ElementVisiable_Slot;
    preset Icon = Application::BtnCapsule;
    preset Label = "Caption";
    preset Appearance;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton FOV
  {
    preset Bounds = <671,329,777,429>;
    preset Icon = Application::BtnCircle;
    preset Label = "광각";
    preset Appearance = Application::PushButtonConfig;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <395,361,511,401>;
    preset String = "8K 60";
    preset Font = Resources::FontExtraLarge;
  }

  $rect <840,529,1040,569>
  object Core::PropertyObserver ModeObserver
  {
    preset OnEvent = onEvent;
    preset Outlet = ^Application::Device.Mode;
  }

  // This slot method is executed when the associated property observer 'PropertyObserver' \
  // is notified.
  $rect <840,569,1040,609>
  slot onEvent
  {
    ModeIcon.FrameNumber = (Application::Device.Mode+2)%6;      
  }

  $rect <20,20,160,60>
  object Application::SwitchMode SwitchMode
  {
    preset Bounds = <-800,450,0,900>;
    preset Enabled = false;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object Application::QuickMenu QuickMenu
  {
    preset Bounds = <0,-450,800,0>;
  }

  $rect <20,20,160,60>
  object Application::Parameter Parameter
  {
    preset Bounds = <800,0,1600,450>;
  }

  $rect <20,20,160,60>
  object Application::AlbumView AlbumView
  {
    preset Bounds = <-800,0,0,450>;
  }

  $rect <1280,810,1480,850>
  method void VisibleTrue()
  {
    SD.Visible = true;
    SDBackground.Visible = true;
    Battery.Visible = true;
    FOV.Visible = true;
    Zoom.Visible = true;
    Setting.Visible = true;
    ModeIcon.Visible = true;
    Text.Visible = true;            
  }

  $rect <1280,850,1480,890>
  method void VisibleFalse()
  {
    SD.Visible = false;
    SDBackground.Visible = false;
    Battery.Visible = false;
    FOV.Visible = false;
    Zoom.Visible = false;
    Setting.Visible = false;
    ModeIcon.Visible = false;
    Text.Visible = false;
  }

  $rect <20,20,160,60>
  object Application::VideoSpec VideoSpec
  {
    preset Bounds = <0,450,800,900>;
  }

  $rect <20,20,160,60>
  object Application::HLSpec HLSpec
  {
    preset Bounds = <0,450,800,900>;
  }

  $rect <20,20,160,60>
  object Application::PhotoSpec PhotoSpec
  {
    preset Bounds = <0,450,800,900>;
  }

  $rect <20,20,160,60>
  object Application::TLSpec TLSpec
  {
    preset Bounds = <0,450,800,900>;
  }

  $rect <20,20,160,60>
  object Application::BurstSpec BurstSpec
  {
    preset Bounds = <0,450,800,900>;
  }

  $rect <20,20,160,60>
  object Application::SMSpec SMSpec
  {
    preset Bounds = <0,450,800,900>;
  }

  $rect <1060,699,1260,739>
  method void GridTrue()
  {
    Line.Visible = true;
    Line1.Visible = true;
    Line2.Visible = true;
    Line3.Visible = true;               
  }

  $rect <1060,739,1260,779>
  method void GridFalse()
  {
    Line.Visible = false;
    Line1.Visible = false;
    Line2.Visible = false;
    Line3.Visible = false;
  }

  $rect <20,20,160,60>
  object Views::Line Line
  {
    preset Point2 = <266,450>;
    preset Point1 = <266,0>;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object Views::Line Line1
  {
    preset Point2 = <534,450>;
    preset Point1 = <534,0>;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object Views::Line Line2
  {
    preset Point2 = <0,150>;
    preset Point1 = <800,150>;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object Views::Line Line3
  {
    preset Point2 = <0,300>;
    preset Point1 = <800,300>;
    preset Visible = false;
  }

  $rect <840,700,1040,740>
  object Core::PropertyObserver GridObserver
  {
    preset OnEvent = onEvent1;
    preset Outlet = ^Application::Device.Grid;
  }

  // This slot method is executed when the associated property observer 'PropertyObserver' \
  // is notified.
  $rect <843,740,1043,780>
  slot onEvent1
  {
    if(Application::Device.Grid == true)
      GridTrue();
    else GridFalse();
  }

  $rect <1060,810,1260,850>
  object Core::PropertyObserver ElementObserver
  {
    preset OnEvent = onEvent2;
    preset Outlet = ^Application::Device.MainViewElement;
  }

  // This slot method is executed when the associated property observer 'PropertyObserver' \
  // is notified.
  $rect <1060,850,1260,890>
  slot onEvent2
  {
    if(Application::Device.MainViewElement == true)
      VisibleTrue();
    else VisibleFalse();
  }

  $rect <840,930,1040,970>
  object Core::PropertyObserver ScreenLockObserver
  {
    preset OnEvent = onEvent3;
    preset Outlet = ^Application::Device.ScreenLock;
  }

  // This slot method is executed when the associated property observer 'PropertyObserver' \
  // is notified.
  $rect <840,970,1040,1010>
  slot onEvent3
  {
    if(Application::Device.ScreenLock){
      PresentDialog( LockedScreen, Effects::SlideDownCentered, null, null, null, null, null, null, null, false );
      LockedScreen.Timer.Enabled = true;
    }
  }

  $rect <20,20,160,60>
  object Application::LockedScreen LockedScreen
  {
    preset Bounds = <0,-450,800,0>;
  }

  $reorder EnterQuickMenu 4
  $reorder SDBackground 4
  $reorder Battery 4
  $reorder ModeIcon 4
  $reorder SD 4
  $reorder ElementVisiable_Slot 4
  $reorder EnterAlbum 4
  $reorder EnterSetSpec 4
  $reorder EnterSetParam 4
  $reorder WipeTouchHandler 4
  $reorder SlideTouchHandler 4
  $reorder ScreenTouchHandler 4
  $reorder SelectMode 4
  $reorder Zoom 4
  $reorder Setting 4
  $reorder FOV 4
  $reorder Text 4
  $reorder ModeObserver 4
  $reorder onEvent 4
  $reorder SwitchMode 4
  $reorder QuickMenu 4
  $reorder Parameter 4
  $reorder AlbumView 4
  $reorder VisibleTrue 4
  $reorder VisibleFalse 4
  $reorder VideoSpec 3
  $reorder HLSpec 3
  $reorder PhotoSpec 3
  $reorder TLSpec 3
  $reorder BurstSpec 3
  $reorder SMSpec 3
}

$rect <849,151,1049,191>
$output false
class QuickMenu : Core::Group
{
  $rect <0,520,200,560>
  inherited property Bounds = <0,0,800,450>;

  $rect <0,560,200,600>
  slot EnterMainView
  {
    if(Owner != null)
      Owner.DismissDialog( this, Effects::SlideUpCentered, null, null, null, null, false );

    if(Grid == true){
       Application::Device.Grid = true;
    }
    else{
       Application::Device.Grid = false;
    }

    Application::Device.MainViewElement = true;
  }

  $rect <20,20,160,60>
  object Core::WipeTouchHandler WipeTouchHandler
  {
    preset Bounds = <0,0,800,450>;
    preset OnTop = EnterMainView;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,0,800,450>;
    preset Color = #00000091;
  }

  $rect <20,20,160,60>
  object Views::Line Line
  {
    preset Point2 = <450,440>;
    preset Point1 = <350,440>;
    preset Width = 5;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <33,9,251,215>;
    preset OnPress = QuickCaptureEnable;
    preset Icon = Application::rectbtn;
    preset Label = "Quick Capture";
    preset Appearance = Application::PushButtonConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton1
  {
    preset Bounds = <544,9,770,215>;
    preset OnPress = SetBrightness;
    preset Icon = Application::rectbtn;
    preset Label = "Brightness";
    preset Appearance = Application::PushButtonConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton2
  {
    preset Bounds = <285,9,516,215>;
    preset OnPress = GridVisible;
    preset Icon = Application::rectbtn;
    preset Label = "Grid";
    preset Appearance = Application::PushButtonConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton3
  {
    preset Bounds = <33,215,251,440>;
    preset OnPress = RotationLockEnable;
    preset Icon = Application::rectbtn;
    preset Label = "Rotation Lock";
    preset Appearance = Application::PushButtonConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton4
  {
    preset Bounds = <285,215,516,440>;
    preset OnPress = ScreenLock;
    preset Icon = Application::rectbtn;
    preset Label = "Screen Lock";
    preset Appearance = Application::PushButtonConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton5
  {
    preset Bounds = <544,215,770,440>;
    preset OnPress = EnterSetting;
    preset Icon = Application::rectbtn;
    preset Label = "Setting";
    preset Appearance = Application::PushButtonConfig;
  }

  $rect <0,600,200,640>
  slot EnterSetting
  {
    PresentDialog( Setting, Effects::SlideLeftCentered, null, null, null, null, null, null, null, false );
  }

  $rect <20,20,160,60>
  object Application::Setting Setting
  {
    preset Bounds = <800,0,1600,450>;
  }

  $rect <250,520,450,560>
  slot GridVisible
  {
    if(Grid == true){
      Grid = false;                               
      PushButton2.Icon = Application::rectbtn;
    }
    else{
    Grid = true;
      PushButton2.Icon = Application::rectbtnBlue;
    }

  }

  $rect <0,660,200,700>
  slot QuickCaptureEnable
  {
    if(Application::Device.QuickCapture == false){
       Application::Device.QuickCapture = true;
       PushButton.Icon = Application::rectbtnBlue;
    }
    else{
       Application::Device.QuickCapture = false;
       PushButton.Icon = Application::rectbtn;
    }

  }

  $rect <0,700,200,740>
  slot RotationLockEnable
  {
    if(Application::Device.RotationLock == false){
       Application::Device.RotationLock = true;
       PushButton3.Icon = Application::rectbtnBlue;
    }
    else{
       Application::Device.RotationLock = false;
       PushButton3.Icon = Application::rectbtn;
    }

  }

  $rect <480,520,680,560>
  slot SetDoneBrightness
  {
    VerticalList.ScrollOffset = 4 * Application::Device.Brightness;
    Rectangle1.Visible = false;
    SlideTouchHandler.Enabled = false;
    VerticalList.Visible = false;
    Text.Visible = false;
    SimpleTouchHandler.Enabled = false;

    Line.Visible = true;
    PushButton.Visible = true;
    PushButton1.Visible = true;
    PushButton2.Visible = true;
    PushButton3.Visible = true;
    PushButton4.Visible = true;
    PushButton5.Visible = true;
    Rectangle.Visible = true;
    WipeTouchHandler.Enabled = true;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler
  {
    preset Point4 = <0,0>;
    preset Point3 = <800,0>;
    preset Point2 = <800,450>;
    preset Point1 = <0,450>;
    preset OnPress = SetDoneBrightness;
    preset Enabled = false;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle1
  {
    preset Bounds = <690,25,770,425>;
    preset Color = #5252528D;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object Core::VerticalList VerticalList
  {
    preset Bounds = <690,25,770,425>;
    preset Buffered = true;
    preset Visible = false;
    preset OnLoadItem = OnLoadItem;
    preset SlideHandler = SlideTouchHandler;
    preset ScrollOffset = -400;
    preset SelectedItem = 100;
    preset PaddingTop = 400;
    preset ItemHeight = 4;
    preset NoOfItems = 100;
    preset ItemClass = Views::Rectangle;
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler
  {
    preset Bounds = <690,25,770,425>;
    preset OnSlide = SelectBrightness;
    preset SnapNext = <0,4>;
    preset SlideHorz = false;
    preset RubberBandScrolling = false;
    preset Enabled = false;
  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <480,620,680,660>
  slot OnLoadItem
  {
    var Views::Rectangle itemView = (Views::Rectangle)VerticalList.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( itemView == null )
      return;

    // Configure the item view ...
    itemView.Color  = #FFFFFFFF;
    itemView.Visible = true;

    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    itemView.Bounds.size = point( VerticalList.Bounds.w, VerticalList.ItemHeight );
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <557,164,676,287>;
    preset String = "100%%";
    preset Font = Application::MyFont;
    preset Visible = false;
  }

  $rect <480,700,680,740>
  object Core::PropertyObserver BrightnessObserver
  {
    preset OnEvent = onEvent;
    preset Outlet = ^Application::Device.Brightness;
  }

  // This slot method is executed when the associated property observer 'PropertyObserver' \
  // is notified.
  $rect <480,740,680,780>
  slot onEvent
  {
    Text.String = string(Application::Device.Brightness) + "%%";
  }

  $rect <480,660,680,700>
  slot SelectBrightness
  {
    var int32 itemIndex;
    itemIndex = VerticalList.ScrollOffset / -4;

    Application::Device.Brightness = itemIndex;
  }

  $rect <480,560,680,600>
  slot SetBrightness
  {
    Rectangle1.Visible = true;
    SlideTouchHandler.Enabled = true;
    VerticalList.Visible = true;
    Text.Visible = true;
    SimpleTouchHandler.Enabled = true;

    Line.Visible = false;
    PushButton.Visible = false;
    PushButton1.Visible = false;
    PushButton2.Visible = false;
    PushButton3.Visible = false;
    PushButton4.Visible = false;
    PushButton5.Visible = false;
    Rectangle.Visible = false;
    WipeTouchHandler.Enabled = false;
  }

  $rect <250,560,450,600>
  property bool Grid = 0;

  $rect <250,600,450,640>
  onset Grid
  {
    // The value doesn't change - nothing to do.
    if ( pure Grid == value )
      return;

    // Remember the property's new value.
    pure Grid = value;
  }

  $rect <740,520,940,560>
  slot ScreenLock
  {
    if(Owner != null)
      Owner.DismissDialog( this, Effects::SlideUpCentered, null, null, null, null, false );

    if(Grid == true){
       Application::Device.Grid = true;
    }
    else{
       Application::Device.Grid = false;
    }

    Application::Device.MainViewElement = true;
    Application::Device.ScreenLock = true;
  }
}

$rect <589,151,789,191>
$output false
class Parameter : Core::Group
{
  $rect <0,490,200,530>
  inherited property Bounds = <0,0,800,450>;

  $rect <20,20,160,60>
  object Core::WipeTouchHandler WipeTouchHandler
  {
    preset Bounds = <0,0,800,450>;
    preset OnRight = EnterMainView;
    preset OnLeft = null;
  }

  $rect <210,490,410,530>
  slot EnterMainView
  {
    if(Owner != null)
      Owner.DismissDialog( this, Effects::SlideRightCentered, null, null, null, null, false );
    Application::Device.MainViewElement = true;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <467,0,800,450>;
    preset Color = #000000BE;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle1
  {
    preset Bounds = <502,44,633,79>;
    preset Color = #009AFFFF;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle2
  {
    preset Bounds = <633,44,765,79>;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Line Line
  {
    preset Point2 = <20,275>;
    preset Point1 = <20,185>;
    preset Width = 5;
  }

  $rect <430,490,630,530>
  slot SetAuto
  {
    Rectangle1.Color = #009AFFFF;
    Rectangle2.Color = #000000FF;

    MCR.Visible = false;
    ISO.Visible = false;
    MS.Visible = false;
    SS.Visible = false;
    MWB.Visible = false;

    ACR.Visible = true;
    EV.Visible = true;
    PM.Visible = true;
    AS.Visible = true;
    AWB.Visible = true;
  }

  $rect <430,530,630,570>
  slot SetManual
  {
    Rectangle1.Color = #000000FF;
    Rectangle2.Color = #009AFFFF;

    MCR.Visible = true;
    ISO.Visible = true;
    MS.Visible = true;
    SS.Visible = true;
    MWB.Visible = true;

    ACR.Visible = false;
    EV.Visible = false;
    PM.Visible = false;
    AS.Visible = false;
    AWB.Visible = false;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton MCR
  {
    preset Bounds = <509,98,627,204>;
    preset Visible = false;
    preset OnPress = btnSlot5;
    preset Icon = Application::BtnCircle;
    preset Label = "Color\nRecipe";
    preset Appearance = Application::PushButtonConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton MWB
  {
    preset Bounds = <643,204,758,315>;
    preset Visible = false;
    preset OnPress = btnSlot8;
    preset Icon = Application::BtnCircle;
    preset Label = "White balance";
    preset Appearance = Application::PushButtonConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton MS
  {
    preset Bounds = <510,315,627,426>;
    preset Visible = false;
    preset OnPress = btnSlot9;
    preset Icon = Application::BtnCircle;
    preset Label = "Sharpness";
    preset Appearance = Application::PushButtonConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton SS
  {
    preset Bounds = <643,98,758,204>;
    preset Visible = false;
    preset OnPress = btnSlot6;
    preset Icon = Application::BtnCircle;
    preset Label = "Shutter Speed";
    preset Appearance = Application::PushButtonConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton ISO
  {
    preset Bounds = <509,204,627,315>;
    preset Visible = false;
    preset OnPress = btnSlot7;
    preset Icon = Application::BtnCircle;
    preset Label = "ISO";
    preset Appearance = Application::PushButtonConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Auto
  {
    preset Bounds = <502,44,633,79>;
    preset OnPress = SetAuto;
    preset Label = "자동";
    preset Appearance = Application::PushButtonConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Manual
  {
    preset Bounds = <633,44,765,79>;
    preset OnPress = SetManual;
    preset Label = "수동";
    preset Appearance = Application::PushButtonConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton ACR
  {
    preset Bounds = <509,98,627,204>;
    preset Visible = true;
    preset Icon = Application::BtnCircle;
    preset Label = "Color\nRecipe";
    preset Appearance = Application::PushButtonConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton AWB
  {
    preset Bounds = <643,204,758,315>;
    preset Visible = true;
    preset OnPress = btnSlot3;
    preset Icon = Application::BtnCircle;
    preset Label = "White balance";
    preset Appearance = Application::PushButtonConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton AS
  {
    preset Bounds = <510,315,627,426>;
    preset Visible = true;
    preset OnPress = btnSlot4;
    preset Icon = Application::BtnCircle;
    preset Label = "Sharpness";
    preset Appearance = Application::PushButtonConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton EV
  {
    preset Bounds = <643,98,758,204>;
    preset Visible = true;
    preset OnPress = btnSlot1;
    preset Icon = Application::BtnCircle;
    preset Label = "EV";
    preset Appearance = Application::PushButtonConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PM
  {
    preset Bounds = <509,204,627,315>;
    preset Visible = true;
    preset OnPress = btnSlot2;
    preset Icon = Application::BtnCircle;
    preset Label = "Photometric mode";
    preset Appearance = Application::PushButtonConfig;
  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <0,610,200,650>
  slot OnLoadACRItem
  {
    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = ACRList.Item;
    var Views::Text itemView = (Views::Text)ACRList.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( itemView == null )
      return;

    array string myitem[5];
    myitem[0] = "표준";
    myitem[1] = "비비드";
    myitem[2] = "웜";
    myitem[3] = "쿨";
    myitem[4] = "레트로";
    // Configure the item view ...
    itemView.String = myitem[itemNo];
    itemView.Font   = Application::MyFont;
    itemView.Color  = #FFFFFFFF;

    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    itemView.Bounds.size = point( ACRList.Bounds.w, ACRList.ItemHeight );
  }

  $rect <0,650,200,690>
  slot SetACR
  {
    var int32 centerPosition = 225;
    ;

    var int32 i;

    for (i = 0; i < ACRList.NoOfItems; i++){
      var Views::Text itemView = (Views::Text)ACRList.GetViewForItem(i);

      // 아이템이 현재 화면에 보이는 경우에만
      if (itemView != null){
          // 아이템의 현재 위치 계산 (아이템의 왼쪽 상단 X좌표 + 아이템 너비 / 2)
          var int32 itemCenter = itemView.Bounds.y1 + (itemView.Bounds.h / 2);

          // 중앙 위치와 아이템 중심 위치의 차이 계산
          var int32 distanceFromCenter = itemCenter - centerPosition;

          // 중앙에 가까운 아이템은 색상을 하늘색으로, 나머지는 하얀색으로
          if (distanceFromCenter >= -20 && distanceFromCenter <= 20){
              itemView.Color = #77CCFFFF;  // 하늘색
              Application::Device.AutoColorRecipe = i;
          }
          else{
              itemView.Color = #FFFFFFFF;  // 기본 하얀색
          }
      }
    }
  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <210,610,410,650>
  slot OnLoadEVItem
  {
    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = EVList.Item;
    var Views::Text itemView = (Views::Text)EVList.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( itemView == null )
      return;

    array string myitem[19];
    myitem[0] = "-3.0";
    myitem[1] = "-2.7";
    myitem[2] = "-2.3";
    myitem[3] = "-2.0";
    myitem[4] = "-1.7";
    myitem[5] = "-1.3";
    myitem[6] = "-1.0";
    myitem[7] = "-0.7";
    myitem[8] = "-0.3";
    myitem[9] = "0";
    myitem[10] = "0.3";
    myitem[11] = "0.7";
    myitem[12] = "1.0";
    myitem[13] = "1.3";
    myitem[14] = "1.7";
    myitem[15] = "2.0";
    myitem[16] = "2.3";
    myitem[17] = "2.7";
    myitem[18] = "3.0";
    // Configure the item view ...
    itemView.String = myitem[itemNo];
    itemView.Font   = Application::MyFont;
    itemView.Color  = #FFFFFFFF;

    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    itemView.Bounds.size = point( EVList.Bounds.w, EVList.ItemHeight );
  }

  $rect <210,650,410,690>
  slot SetEV
  {
    var int32 centerPosition = 225;

    var int32 i;

    for (i = 0; i < EVList.NoOfItems; i++){
      var Views::Text itemView = (Views::Text)EVList.GetViewForItem(i);

      // 아이템이 현재 화면에 보이는 경우에만
      if (itemView != null){
          // 아이템의 현재 위치 계산 (아이템의 왼쪽 상단 X좌표 + 아이템 너비 / 2)
          var int32 itemCenter = itemView.Bounds.y1 + (itemView.Bounds.h / 2);

          // 중앙 위치와 아이템 중심 위치의 차이 계산
          var int32 distanceFromCenter = itemCenter - centerPosition;

          // 중앙에 가까운 아이템은 색상을 하늘색으로, 나머지는 하얀색으로
          if (distanceFromCenter >= -20 && distanceFromCenter <= 20){
              itemView.Color = #77CCFFFF;  // 하늘색
              Application::Device.AutoEV = i;
          }
          else{
              itemView.Color = #FFFFFFFF;  // 기본 하얀색
          }
      }
    }
  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <420,610,620,650>
  slot OnLoadPMItem
  {
    /*

      Hint:

      - The code below demonstrates a simple usage of the list component.

      - The list component creates and manages automatically view item instances of
        the class specified in its property 'ItemClass'. In this example it is the
        class 'Views::Text'.

      - When you change the 'ItemClass' property you will also need to replace
        accordingly all 'Views::Text' occurrences in the below code.

      - You will also need to adapt the initialization of the 'itemView'.

    */

    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = ACRList.Item;
    var Views::Text itemView = (Views::Text)ACRList.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( itemView == null )
      return;

    // Configure the item view ...
    itemView.String = string( itemNo ) + "분";
    itemView.Font   = Application::MyFont2;
    itemView.Color  = #FFFFFFFF;

    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    itemView.Bounds.size = point( ACRList.Bounds.w, ACRList.ItemHeight );
  }

  $rect <420,650,620,690>
  slot SetPM
  {
    var int32 centerPosition = 125;

    var int32 i;

    for (i = 0; i < ACRList.NoOfItems; i++){
      var Views::Text itemView = (Views::Text)ACRList.GetViewForItem(i);

      // 아이템이 현재 화면에 보이는 경우에만
      if (itemView != null){
          // 아이템의 현재 위치 계산 (아이템의 왼쪽 상단 X좌표 + 아이템 너비 / 2)
          var int32 itemCenter = itemView.Bounds.y1 + (itemView.Bounds.h / 2);

          // 중앙 위치와 아이템 중심 위치의 차이 계산
          var int32 distanceFromCenter = itemCenter - centerPosition;

          // 중앙에 가까운 아이템은 색상을 하늘색으로, 나머지는 하얀색으로
          if (distanceFromCenter >= -20 && distanceFromCenter <= 20){
              itemView.Color = #77CCFFFF;  // 하늘색
              Application::Device.Minute = i;
          }
          else{
              itemView.Color = #FFFFFFFF;  // 기본 하얀색
          }
      }
    }
  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <630,610,830,650>
  slot OnLoadAWBItem
  {
    /*

      Hint:

      - The code below demonstrates a simple usage of the list component.

      - The list component creates and manages automatically view item instances of
        the class specified in its property 'ItemClass'. In this example it is the
        class 'Views::Text'.

      - When you change the 'ItemClass' property you will also need to replace
        accordingly all 'Views::Text' occurrences in the below code.

      - You will also need to adapt the initialization of the 'itemView'.

    */

    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = ACRList.Item;
    var Views::Text itemView = (Views::Text)ACRList.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( itemView == null )
      return;

    // Configure the item view ...
    itemView.String = string( itemNo ) + "분";
    itemView.Font   = Application::MyFont2;
    itemView.Color  = #FFFFFFFF;

    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    itemView.Bounds.size = point( ACRList.Bounds.w, ACRList.ItemHeight );
  }

  $rect <631,650,831,690>
  slot SetAWB
  {
    var int32 centerPosition = 125;

    var int32 i;

    for (i = 0; i < ACRList.NoOfItems; i++){
      var Views::Text itemView = (Views::Text)ACRList.GetViewForItem(i);

      // 아이템이 현재 화면에 보이는 경우에만
      if (itemView != null){
          // 아이템의 현재 위치 계산 (아이템의 왼쪽 상단 X좌표 + 아이템 너비 / 2)
          var int32 itemCenter = itemView.Bounds.y1 + (itemView.Bounds.h / 2);

          // 중앙 위치와 아이템 중심 위치의 차이 계산
          var int32 distanceFromCenter = itemCenter - centerPosition;

          // 중앙에 가까운 아이템은 색상을 하늘색으로, 나머지는 하얀색으로
          if (distanceFromCenter >= -20 && distanceFromCenter <= 20){
              itemView.Color = #77CCFFFF;  // 하늘색
              Application::Device.Minute = i;
          }
          else{
              itemView.Color = #FFFFFFFF;  // 기본 하얀색
          }
      }
    }
  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <840,610,1040,650>
  slot OnLoadASItem
  {
    /*

      Hint:

      - The code below demonstrates a simple usage of the list component.

      - The list component creates and manages automatically view item instances of
        the class specified in its property 'ItemClass'. In this example it is the
        class 'Views::Text'.

      - When you change the 'ItemClass' property you will also need to replace
        accordingly all 'Views::Text' occurrences in the below code.

      - You will also need to adapt the initialization of the 'itemView'.

    */

    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = ACRList.Item;
    var Views::Text itemView = (Views::Text)ACRList.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( itemView == null )
      return;

    // Configure the item view ...
    itemView.String = string( itemNo ) + "분";
    itemView.Font   = Application::MyFont2;
    itemView.Color  = #FFFFFFFF;

    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    itemView.Bounds.size = point( ACRList.Bounds.w, ACRList.ItemHeight );
  }

  $rect <841,650,1041,690>
  slot SetAS
  {
    var int32 centerPosition = 125;

    var int32 i;

    for (i = 0; i < ACRList.NoOfItems; i++){
      var Views::Text itemView = (Views::Text)ACRList.GetViewForItem(i);

      // 아이템이 현재 화면에 보이는 경우에만
      if (itemView != null){
          // 아이템의 현재 위치 계산 (아이템의 왼쪽 상단 X좌표 + 아이템 너비 / 2)
          var int32 itemCenter = itemView.Bounds.y1 + (itemView.Bounds.h / 2);

          // 중앙 위치와 아이템 중심 위치의 차이 계산
          var int32 distanceFromCenter = itemCenter - centerPosition;

          // 중앙에 가까운 아이템은 색상을 하늘색으로, 나머지는 하얀색으로
          if (distanceFromCenter >= -20 && distanceFromCenter <= 20){
              itemView.Color = #77CCFFFF;  // 하늘색
              Application::Device.Minute = i;
          }
          else{
              itemView.Color = #FFFFFFFF;  // 기본 하얀색
          }
      }
    }
  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <0,840,200,880>
  slot OnLoadMCRItem
  {
    /*

      Hint:

      - The code below demonstrates a simple usage of the list component.

      - The list component creates and manages automatically view item instances of
        the class specified in its property 'ItemClass'. In this example it is the
        class 'Views::Text'.

      - When you change the 'ItemClass' property you will also need to replace
        accordingly all 'Views::Text' occurrences in the below code.

      - You will also need to adapt the initialization of the 'itemView'.

    */

    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = ACRList.Item;
    var Views::Text itemView = (Views::Text)ACRList.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( itemView == null )
      return;

    // Configure the item view ...
    itemView.String = string( itemNo ) + "분";
    itemView.Font   = Application::MyFont2;
    itemView.Color  = #FFFFFFFF;

    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    itemView.Bounds.size = point( ACRList.Bounds.w, ACRList.ItemHeight );
  }

  $rect <0,880,200,920>
  slot SetMCR
  {
    var int32 centerPosition = 125;

    var int32 i;

    for (i = 0; i < ACRList.NoOfItems; i++){
      var Views::Text itemView = (Views::Text)ACRList.GetViewForItem(i);

      // 아이템이 현재 화면에 보이는 경우에만
      if (itemView != null){
          // 아이템의 현재 위치 계산 (아이템의 왼쪽 상단 X좌표 + 아이템 너비 / 2)
          var int32 itemCenter = itemView.Bounds.y1 + (itemView.Bounds.h / 2);

          // 중앙 위치와 아이템 중심 위치의 차이 계산
          var int32 distanceFromCenter = itemCenter - centerPosition;

          // 중앙에 가까운 아이템은 색상을 하늘색으로, 나머지는 하얀색으로
          if (distanceFromCenter >= -20 && distanceFromCenter <= 20){
              itemView.Color = #77CCFFFF;  // 하늘색
              Application::Device.Minute = i;
          }
          else{
              itemView.Color = #FFFFFFFF;  // 기본 하얀색
          }
      }
    }
  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <210,840,410,880>
  slot OnLoadSSItem
  {
    /*

      Hint:

      - The code below demonstrates a simple usage of the list component.

      - The list component creates and manages automatically view item instances of
        the class specified in its property 'ItemClass'. In this example it is the
        class 'Views::Text'.

      - When you change the 'ItemClass' property you will also need to replace
        accordingly all 'Views::Text' occurrences in the below code.

      - You will also need to adapt the initialization of the 'itemView'.

    */

    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = ACRList.Item;
    var Views::Text itemView = (Views::Text)ACRList.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( itemView == null )
      return;

    // Configure the item view ...
    itemView.String = string( itemNo ) + "분";
    itemView.Font   = Application::MyFont2;
    itemView.Color  = #FFFFFFFF;

    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    itemView.Bounds.size = point( ACRList.Bounds.w, ACRList.ItemHeight );
  }

  $rect <210,880,410,920>
  slot SetSS
  {
    var int32 centerPosition = 125;

    var int32 i;

    for (i = 0; i < ACRList.NoOfItems; i++){
      var Views::Text itemView = (Views::Text)ACRList.GetViewForItem(i);

      // 아이템이 현재 화면에 보이는 경우에만
      if (itemView != null){
          // 아이템의 현재 위치 계산 (아이템의 왼쪽 상단 X좌표 + 아이템 너비 / 2)
          var int32 itemCenter = itemView.Bounds.y1 + (itemView.Bounds.h / 2);

          // 중앙 위치와 아이템 중심 위치의 차이 계산
          var int32 distanceFromCenter = itemCenter - centerPosition;

          // 중앙에 가까운 아이템은 색상을 하늘색으로, 나머지는 하얀색으로
          if (distanceFromCenter >= -20 && distanceFromCenter <= 20){
              itemView.Color = #77CCFFFF;  // 하늘색
              Application::Device.Minute = i;
          }
          else{
              itemView.Color = #FFFFFFFF;  // 기본 하얀색
          }
      }
    }
  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <420,840,620,880>
  slot OnLoadISOItem
  {
    /*

      Hint:

      - The code below demonstrates a simple usage of the list component.

      - The list component creates and manages automatically view item instances of
        the class specified in its property 'ItemClass'. In this example it is the
        class 'Views::Text'.

      - When you change the 'ItemClass' property you will also need to replace
        accordingly all 'Views::Text' occurrences in the below code.

      - You will also need to adapt the initialization of the 'itemView'.

    */

    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = ACRList.Item;
    var Views::Text itemView = (Views::Text)ACRList.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( itemView == null )
      return;

    // Configure the item view ...
    itemView.String = string( itemNo ) + "분";
    itemView.Font   = Application::MyFont2;
    itemView.Color  = #FFFFFFFF;

    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    itemView.Bounds.size = point( ACRList.Bounds.w, ACRList.ItemHeight );
  }

  $rect <420,880,620,920>
  slot SetISO
  {
    var int32 centerPosition = 125;

    var int32 i;

    for (i = 0; i < ACRList.NoOfItems; i++){
      var Views::Text itemView = (Views::Text)ACRList.GetViewForItem(i);

      // 아이템이 현재 화면에 보이는 경우에만
      if (itemView != null){
          // 아이템의 현재 위치 계산 (아이템의 왼쪽 상단 X좌표 + 아이템 너비 / 2)
          var int32 itemCenter = itemView.Bounds.y1 + (itemView.Bounds.h / 2);

          // 중앙 위치와 아이템 중심 위치의 차이 계산
          var int32 distanceFromCenter = itemCenter - centerPosition;

          // 중앙에 가까운 아이템은 색상을 하늘색으로, 나머지는 하얀색으로
          if (distanceFromCenter >= -20 && distanceFromCenter <= 20){
              itemView.Color = #77CCFFFF;  // 하늘색
              Application::Device.Minute = i;
          }
          else{
              itemView.Color = #FFFFFFFF;  // 기본 하얀색
          }
      }
    }
  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <630,840,830,880>
  slot OnLoadMWBItem
  {
    /*

      Hint:

      - The code below demonstrates a simple usage of the list component.

      - The list component creates and manages automatically view item instances of
        the class specified in its property 'ItemClass'. In this example it is the
        class 'Views::Text'.

      - When you change the 'ItemClass' property you will also need to replace
        accordingly all 'Views::Text' occurrences in the below code.

      - You will also need to adapt the initialization of the 'itemView'.

    */

    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = ACRList.Item;
    var Views::Text itemView = (Views::Text)ACRList.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( itemView == null )
      return;

    // Configure the item view ...
    itemView.String = string( itemNo ) + "분";
    itemView.Font   = Application::MyFont2;
    itemView.Color  = #FFFFFFFF;

    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    itemView.Bounds.size = point( ACRList.Bounds.w, ACRList.ItemHeight );
  }

  $rect <631,880,831,920>
  slot SetMWB
  {
    var int32 centerPosition = 125;

    var int32 i;

    for (i = 0; i < ACRList.NoOfItems; i++){
      var Views::Text itemView = (Views::Text)ACRList.GetViewForItem(i);

      // 아이템이 현재 화면에 보이는 경우에만
      if (itemView != null){
          // 아이템의 현재 위치 계산 (아이템의 왼쪽 상단 X좌표 + 아이템 너비 / 2)
          var int32 itemCenter = itemView.Bounds.y1 + (itemView.Bounds.h / 2);

          // 중앙 위치와 아이템 중심 위치의 차이 계산
          var int32 distanceFromCenter = itemCenter - centerPosition;

          // 중앙에 가까운 아이템은 색상을 하늘색으로, 나머지는 하얀색으로
          if (distanceFromCenter >= -20 && distanceFromCenter <= 20){
              itemView.Color = #77CCFFFF;  // 하늘색
              Application::Device.Minute = i;
          }
          else{
              itemView.Color = #FFFFFFFF;  // 기본 하얀색
          }
      }
    }
  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <840,840,1040,880>
  slot OnLoadMSItem
  {
    /*

      Hint:

      - The code below demonstrates a simple usage of the list component.

      - The list component creates and manages automatically view item instances of
        the class specified in its property 'ItemClass'. In this example it is the
        class 'Views::Text'.

      - When you change the 'ItemClass' property you will also need to replace
        accordingly all 'Views::Text' occurrences in the below code.

      - You will also need to adapt the initialization of the 'itemView'.

    */

    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = ACRList.Item;
    var Views::Text itemView = (Views::Text)ACRList.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( itemView == null )
      return;

    // Configure the item view ...
    itemView.String = string( itemNo ) + "분";
    itemView.Font   = Application::MyFont2;
    itemView.Color  = #FFFFFFFF;

    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    itemView.Bounds.size = point( ACRList.Bounds.w, ACRList.ItemHeight );
  }

  $rect <841,880,1041,920>
  slot SetMS
  {
    var int32 centerPosition = 125;

    var int32 i;

    for (i = 0; i < ACRList.NoOfItems; i++){
      var Views::Text itemView = (Views::Text)ACRList.GetViewForItem(i);

      // 아이템이 현재 화면에 보이는 경우에만
      if (itemView != null){
          // 아이템의 현재 위치 계산 (아이템의 왼쪽 상단 X좌표 + 아이템 너비 / 2)
          var int32 itemCenter = itemView.Bounds.y1 + (itemView.Bounds.h / 2);

          // 중앙 위치와 아이템 중심 위치의 차이 계산
          var int32 distanceFromCenter = itemCenter - centerPosition;

          // 중앙에 가까운 아이템은 색상을 하늘색으로, 나머지는 하얀색으로
          if (distanceFromCenter >= -20 && distanceFromCenter <= 20){
              itemView.Color = #77CCFFFF;  // 하늘색
              Application::Device.Minute = i;
          }
          else{
              itemView.Color = #FFFFFFFF;  // 기본 하얀색
          }
      }
    }
  }

  $rect <20,20,160,60>
  object Core::VerticalList ACRList
  {
    preset Bounds = <627,0,800,450>;
    preset Enabled;
    preset Visible = false;
    preset OnUpdate = SetACR;
    preset OnLoadItem = OnLoadACRItem;
    preset PaddingBottom = 175;
    preset SlideHandler = ACRSlide;
    preset PaddingTop = 175;
    preset ItemHeight = 100;
    preset NoOfItems = 5;
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler ACRSlide
  {
    preset Bounds = <627,0,800,450>;
    preset SnapNext = <0,50>;
    preset Enabled = false;
  }

  $rect <0,690,200,730>
  slot btnSlot
  {
    UnvisibleParamElement();
    EVList.Visible = true;
    EVSlide.Enabled = true;
    SimpleTouchHandler.Enabled = true;
  }

  $rect <690,490,890,530>
  method void UnvisibleParamElement()
  {
    WipeTouchHandler.Enabled = false;

    ACR.Visible = false;
    AS.Visible = false;
    AWB.Visible = false;
    Auto.Visible = false;
    EV.Visible = false;
    ISO.Visible = false;
    MCR.Visible = false;
    MS.Visible = false;
    MWB.Visible = false;
    Manual.Visible = false;
    PM.Visible = false;
    SS.Visible = false;

    Line.Visible = false;
    Rectangle.Visible = false;
    Rectangle1.Visible = false;
    Rectangle2.Visible = false;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler
  {
    preset Point4 = <0,0>;
    preset Point3 = <627,0>;
    preset Point2 = <627,450>;
    preset Point1 = <0,450>;
    preset OnPress = Quit;
    preset Enabled = false;
  }

  $rect <920,490,1120,530>
  slot Quit
  {
    SimpleTouchHandler.Enabled = false;

    ACRList.Visible = false;
    ACRSlide.Enabled = false;

    VisibleParamElement();
  }

  $rect <690,530,890,570>
  method void VisibleParamElement()
  {
    WipeTouchHandler.Enabled = true;

    ACR.Visible = true;
    AS.Visible = true;
    AWB.Visible = true;
    Auto.Visible = true;
    EV.Visible = true;
    ISO.Visible = true;
    MCR.Visible = true;
    MS.Visible = true;
    MWB.Visible = true;
    Manual.Visible = true;
    PM.Visible = true;
    SS.Visible = true;

    Line.Visible = true;
    Rectangle.Visible = true;
    Rectangle1.Visible = true;
    Rectangle2.Visible = true;
  }

  $rect <20,20,160,60>
  object Core::VerticalList EVList
  {
    preset Bounds = <627,0,800,450>;
    preset Enabled;
    preset Visible = false;
    preset OnUpdate = SetEV;
    preset OnLoadItem = OnLoadEVItem;
    preset PaddingBottom = 175;
    preset SlideHandler = EVSlide;
    preset ScrollOffset = -900;
    preset PaddingTop = 175;
    preset ItemHeight = 100;
    preset NoOfItems = 19;
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler EVSlide
  {
    preset Bounds = <627,0,800,450>;
    preset SnapNext = <0,50>;
    preset Enabled = false;
  }

  $rect <210,690,410,730>
  slot btnSlot1
  {
    UnvisibleParamElement();
    ACRList.Visible = true;
    ACRSlide.Enabled = true;
    SimpleTouchHandler.Enabled = true;
  }

  $rect <420,689,620,729>
  slot btnSlot2
  {
    UnvisibleParamElement();
    ACRList.Visible = true;
    ACRSlide.Enabled = true;
    SimpleTouchHandler.Enabled = true;
  }

  $rect <629,689,829,729>
  slot btnSlot3
  {
    UnvisibleParamElement();
    ACRList.Visible = true;
    ACRSlide.Enabled = true;
    SimpleTouchHandler.Enabled = true;
  }

  $rect <840,689,1040,729>
  slot btnSlot4
  {
    UnvisibleParamElement();
    ACRList.Visible = true;
    ACRSlide.Enabled = true;
    SimpleTouchHandler.Enabled = true;
  }

  $rect <0,920,200,960>
  slot btnSlot5
  {
    UnvisibleParamElement();
    ACRList.Visible = true;
    ACRSlide.Enabled = true;
    SimpleTouchHandler.Enabled = true;
  }

  $rect <209,920,409,960>
  slot btnSlot6
  {
    UnvisibleParamElement();
    ACRList.Visible = true;
    ACRSlide.Enabled = true;
    SimpleTouchHandler.Enabled = true;
  }

  $rect <420,920,620,960>
  slot btnSlot7
  {
    UnvisibleParamElement();
    ACRList.Visible = true;
    ACRSlide.Enabled = true;
    SimpleTouchHandler.Enabled = true;
  }

  $rect <629,920,829,960>
  slot btnSlot8
  {
    UnvisibleParamElement();
    ACRList.Visible = true;
    ACRSlide.Enabled = true;
    SimpleTouchHandler.Enabled = true;
  }

  $rect <840,920,1040,960>
  slot btnSlot9
  {
    UnvisibleParamElement();
    ACRList.Visible = true;
    ACRSlide.Enabled = true;
    SimpleTouchHandler.Enabled = true;
  }

  $reorder next 1
  $reorder prev 1
  $reorder Owner 1
  $reorder viewShape 1
  $reorder viewState 1
  $reorder layoutContext 1
  $reorder initLayoutContext 1
  $reorder OnSetStackingPriority 1
  $reorder OnSetLayout 1
  $reorder GetRoot 1
  $reorder Draw 1
  $reorder HandleEvent 1
  $reorder CursorHitTest 1
  $reorder ArrangeView 1
  $reorder MoveView 1
  $reorder GetExtent 1
  $reorder ChangeViewState 1
  $reorder StackingPriority 1
  $reorder Layout 1
  $reorder OnSetBounds 1
  $reorder Bounds 1
  $reorder first 1
  $reorder last 1
  $reorder keyHandlers 1
  $reorder buffer 1
  $reorder dialogStack 1
  $reorder fadersQueue 1
  $reorder pendingFader 1
  $reorder processKeyHandlers 1
  $reorder updateBufferSlot 1
  $reorder drawContent 1
  $reorder recalculateLayout 1
  $reorder updateComponent 1
  $reorder OnSetFocus 1
  $reorder OnGetBuffered 1
}

$rect <318,151,518,191>
$output false
class AlbumView : Core::Group
{
  $rect <20,470,220,510>
  inherited property Bounds = <0,0,800,450>;

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,0,800,450>;
    preset Color = #333333FF;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle1
  {
    preset Bounds = <0,0,800,71>;
    preset Color = #000000FF;
  }

  $rect <240,470,440,510>
  slot EnterMainView
  {
    if(Owner != null)
      Owner.DismissDialog( this, Effects::SlideLeftCentered, null, null, null, null, false );
    Application::Device.MainViewElement = true;
  }

  $rect <20,20,160,60>
  object Core::WipeTouchHandler WipeTouchHandler
  {
    preset Bounds = <0,0,800,450>;
    preset OnLeft = EnterMainView;
  }

  $rect <20,20,160,60>
  object Views::Line Line
  {
    preset Point2 = <775,275>;
    preset Point1 = <775,185>;
    preset Width = 5;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <352,0,452,71>;
    preset String = "앨범";
    preset Font = Application::MyFont;
  }

  $rect <20,20,160,60>
  object Views::Text Text1
  {
    preset Bounds = <208,185,597,271>;
    preset String = "앨범에 파일 없음";
    preset Font = Application::MyFont;
  }
}

$rect <1118,151,1318,191>
$output false
class VideoSpec : Core::Group
{
  $rect <10,490,210,530>
  inherited property Bounds = <0,0,800,450>;

  $rect <10,530,210,570>
  slot EnterMainView
  {
    if(Owner != null)
      Owner.DismissDialog( this, Effects::SlideDownCentered, null, null, null, null, false );
    Application::Device.MainViewElement = true;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,0,800,450>;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Core::WipeTouchHandler WipeTouchHandler
  {
    preset Bounds = <0,0,800,450>;
    preset OnBottom = EnterMainView;
    preset OnLeft = null;
  }

  $rect <20,20,160,60>
  object Views::Line Line
  {
    preset Point2 = <450,17>;
    preset Point1 = <350,17>;
    preset Width = 5;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <274,28,526,69>;
    preset String = "동영상";
    preset Font = Application::MyFont;
  }

  // This method is called by 'HorizontalList' every time the list loads or updates \
  // an item.
  $rect <450,530,650,570>
  slot OnLoadItem
  {
    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = HorizontalList.Item;
    var Views::Text itemView = (Views::Text)HorizontalList.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( itemView == null )
      return;

    array string myItem[4];
    myItem[0] = "8K";
    myItem[1] = "4K";
    myItem[2] = "2.7K";
    myItem[3] = "1080P";

    // Configure the item view ...
    itemView.String = myItem[itemNo];
    itemView.Font   = Resources::FontMedium;
    itemView.Color  = #FFFFFFFF;


    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    itemView.Bounds.size = point( HorizontalList.ItemWidth, HorizontalList.Bounds.h );
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler
  {
    preset Bounds = <0,128,800,225>;
    preset SnapNext = <150,0>;
  }

  $rect <20,20,160,60>
  object Core::HorizontalList HorizontalList
  {
    preset Bounds = <0,128,800,225>;
    preset Focus = null;
    preset OnUpdate = SetResolution;
    preset OnLoadItem = OnLoadItem;
    preset PaddingRight = 330;
    preset SlideHandler = SlideTouchHandler;
    preset ScrollOffset = 0;
    preset SelectedItem = 0;
    preset PaddingLeft = 320;
    preset ItemWidth = 150;
    preset NoOfItems = 4;
    preset ItemClass = Views::Text;
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler1
  {
    preset Bounds = <0,255,800,352>;
    preset SnapNext = <150,0>;
  }

  $rect <20,20,160,60>
  object Core::HorizontalList HorizontalList1
  {
    preset Bounds = <0,255,800,352>;
    preset Focus = null;
    preset OnUpdate = SetFrameRate;
    preset OnLoadItem = OnLoadItem1;
    preset PaddingRight = 330;
    preset SlideHandler = SlideTouchHandler1;
    preset ScrollOffset = 0;
    preset SelectedItem = 0;
    preset PaddingLeft = 320;
    preset ItemWidth = 150;
    preset NoOfItems = 4;
    preset ItemClass = Views::Text;
  }

  // This method is called by 'HorizontalList' every time the list loads or updates \
  // an item.
  $rect <450,570,650,610>
  slot OnLoadItem1
  {
    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = HorizontalList1.Item;
    var Views::Text itemView = (Views::Text)HorizontalList1.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( itemView == null )
      return;


    array string myItem[6];
    myItem[0] = "60";
    myItem[1] = "50";
    myItem[2] = "48";
    myItem[3] = "30";
    myItem[4] = "25";
    myItem[5] = "24";

    // Configure the item view ...
    itemView.String = myItem[itemNo];
    itemView.Font   = Resources::FontMedium;
    itemView.Color  = #FFFFFFFF;

    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    itemView.Bounds.size = point( HorizontalList1.ItemWidth, HorizontalList1.Bounds.h );
  }

  $rect <20,20,160,60>
  object Views::Text Text1
  {
    preset Bounds = <350,98,450,128>;
    preset String = "해상도";
    preset Font = Application::MyFont2;
    preset Color = #565656FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text2
  {
    preset Bounds = <350,225,450,255>;
    preset String = "프레임";
    preset Font = Application::MyFont2;
    preset Color = #565656FF;
  }

  $rect <230,570,430,610>
  slot SetFrameRate
  {
    var int32 centerPosition = 400;

    var int32 i;

    for (i = 0; i < HorizontalList1.NoOfItems; i++){
      var Views::Text itemView = (Views::Text)HorizontalList1.GetViewForItem(i);

      if (itemView != null){
          var int32 itemCenter = itemView.Bounds.x1 + (itemView.Bounds.w / 2);

          var int32 distanceFromCenter = itemCenter - centerPosition;

          if (distanceFromCenter >= -20 && distanceFromCenter <= 20){
              itemView.Color = #77CCFFFF;
              Application::Device.VideoFrameRate = i;
          }
          else{
              itemView.Color = #FFFFFFFF;
          }
      }
    }
  }

  $rect <230,530,430,570>
  slot SetResolution
  {
    var int32 centerPosition = 400;

    var int32 i;

    for (i = 0; i < HorizontalList.NoOfItems; i++){
      var Views::Text itemView = (Views::Text)HorizontalList.GetViewForItem(i);

      // 아이템이 현재 화면에 보이는 경우에만
      if (itemView != null){
          // 아이템의 현재 위치 계산 (아이템의 왼쪽 상단 X좌표 + 아이템 너비 / 2)
          var int32 itemCenter = itemView.Bounds.x1 + (itemView.Bounds.w / 2);

          // 중앙 위치와 아이템 중심 위치의 차이 계산
          var int32 distanceFromCenter = itemCenter - centerPosition;

          // 중앙에 가까운 아이템은 색상을 하늘색으로, 나머지는 하얀색으로
          if (distanceFromCenter >= -20 && distanceFromCenter <= 20){
              itemView.Color = #77CCFFFF;  // 하늘색
              Application::Device.VideoResolution = i;
          }
          else{
              itemView.Color = #FFFFFFFF;  // 기본 하얀색
          }
      }
    }
  }

  $rect <830,30,1030,70>
  property int32 Mode;

  $rect <830,70,1030,110>
  onset Mode
  {
    // The value doesn't change - nothing to do.
    if ( pure Mode == value )
      return;

    // Remember the property's new value.
    pure Mode = value;

    switch(value){ 
      case 1: { Text.String = "타임랩스"; }
      case 2: { Text.String = "하이퍼랩스"; }
      case 3: { Text.String = "슬로우모션"; }
      case 4: { Text.String = "연사"; }
      case 5: { Text.String = "사진"; }      
      default: { Text.String = "동영상"; }
    } ;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton HDR
  {
    preset Bounds = <31,364,249,436>;
    preset OnPress = EnterHDRSetting;
    preset Label = "HDR ON";
    preset Appearance = Application::PushButtonConfig1;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Ratio
  {
    preset Bounds = <291,364,509,436>;
    preset OnPress = EnterRatioSetting;
    preset Label = "16:9";
    preset Appearance = Application::PushButtonConfig1;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Time
  {
    preset Bounds = <553,364,771,436>;
    preset OnPress = EnterTimeSetting;
    preset Label = "무한";
    preset Appearance = Application::PushButtonConfig1;
  }

  $rect <670,490,870,530>
  slot EnterHDRSetting
  {
    PresentDialog( HDRSetting, Effects::SlideUpCentered, null, null, null, null, null, null, null, false );
    HDRSetting.HorizontalList.ScrollOffset = -160 * Application::Device.VideoHDR;
  }

  $rect <20,20,160,60>
  object Application::HDRSetting HDRSetting
  {
    preset Bounds = <0,450,800,900>;
  }

  $rect <-220,360,-20,400>
  object Core::PropertyObserver HDRObserver
  {
    preset OnEvent = onEvent;
    preset Outlet = ^Application::Device.VideoHDR;
  }

  // This slot method is executed when the associated property observer 'PropertyObserver' \
  // is notified.
  $rect <-220,400,-20,440>
  slot onEvent
  {
    if( Application::Device.VideoHDR == 1 )
      HDR.Label = "HDR OFF";
    else HDR.Label = "HDR ON";
  }

  $rect <669,529,869,569>
  slot EnterRatioSetting
  {
    PresentDialog( RatioSetting, Effects::SlideUpCentered, null, null, null, null, null, null, null, false );
    RatioSetting.HorizontalList.ScrollOffset = -160 * Application::Device.VideoRatio;
  }

  $rect <669,569,869,609>
  slot EnterTimeSetting
  {
    PresentDialog( TimeSetting, Effects::SlideUpCentered, null, null, null, null, null, null, null, false );
    TimeSetting.HorizontalList.ScrollOffset = -160 * Application::Device.VideoTime;
  }

  $rect <-220,449,-20,489>
  object Core::PropertyObserver RatioObserver
  {
    preset OnEvent = onEvent1;
    preset Outlet = ^Application::Device.VideoRatio;
  }

  // This slot method is executed when the associated property observer 'PropertyObserver' \
  // is notified.
  $rect <-220,489,-20,529>
  slot onEvent1
  {
    if( Application::Device.VideoRatio == 0 )
      Ratio.Label = "16:9";
    else Ratio.Label = "4:3";
  }

  $rect <-220,540,-20,580>
  object Core::PropertyObserver TimeObserver
  {
    preset OnEvent = onEvent2;
    preset Outlet = ^Application::Device.VideoTime;
  }

  // This slot method is executed when the associated property observer 'PropertyObserver' \
  // is notified.
  $rect <-220,580,-20,620>
  slot onEvent2
  {
    array string myItem[12];
    myItem[0] = "무한";
    myItem[1] = "15s";
    myItem[2] = "30s";
    myItem[3] = "1m";
    myItem[4] = "3m";
    myItem[5] = "5m";
    myItem[6] = "10m";
    myItem[7] = "15m";
    myItem[8] = "30m";
    myItem[9] = "1h";
    myItem[10] = "2h";
    myItem[11] = "3h";

    Time.Label = myItem[Application::Device.VideoTime];
  }

  $rect <20,20,160,60>
  object Application::RatioSetting RatioSetting
  {
    preset Bounds = <0,449,800,899>;
  }

  $rect <20,20,160,60>
  object Application::TimeSetting TimeSetting
  {
    preset Bounds = <0,449,800,899>;
  }
}

$rect <40,151,240,191>
$output false
class SwitchMode : Core::Group
{
  $rect <10,480,210,520>
  inherited property Bounds = <0,0,800,450>;

  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler
  {
    preset Bounds = <0,0,800,450>;
    preset OnSlide = RestartTimer;
    preset OnEnd = RestartTimer;
    preset OnStart = RestartTimer;
    preset SnapNext = <160,0>;
    preset ResetDelay = 200;
    preset SpeedLimit = 80;
    preset Friction = 0.5;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,0,800,450>;
    preset Color = #00000064;
  }

  // This method is called by 'HorizontalList' every time the list loads or updates \
  // an item.
  $rect <10,520,210,560>
  slot OnLoadItem
  {
    var int32        itemNo   = HorizontalList.Item;
    var Views::Image itemView = (Views::Image)HorizontalList.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( itemView == null )
      return;
        
    // Configure the item view ...
    itemView.Bitmap      = Application::SymbolIconsMedium;
    itemView.FrameNumber = ( itemNo % itemView.Bitmap.NoOfFrames );


    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    itemView.Bounds.size = point( HorizontalList.ItemWidth, HorizontalList.Bounds.h );
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <274,302,526,345>;
    preset String = "동영상";
    preset Font = Application::MyFont;
  }

  $rect <20,20,160,60>
  object Views::Text Text1
  {
    preset Bounds = <264,350,537,418>;
    preset WrapText = true;
    preset Alignment = Views::TextAlignment[AlignHorzCenter, AlignVertTop];
    preset String = "해상도와 프레임 레이트를 선택하여 동영상을 촬영합니다.";
    preset Font = Application::MyFont1;
  }

  $rect <10,560,210,600>
  slot SelectMode
  {
    var int32 itemIndex;
    itemIndex = HorizontalList.ScrollOffset / -160;
    switch(itemIndex){ 
      case 1: { Text.String = "타임랩스"; Text1.String = "해상도와 프레임 레이트를 선택하여 타임랩스를 촬영합니다.";}
      case 2: { Text.String = "하이퍼랩스"; Text1.String = "해상도와 프레임 레이트를 선택하여 하이퍼랩스를 촬영합니다."; }
      case 3: { Text.String = "슬로우모션"; Text1.String = "해상도와 프레임 레이트를 선택하여 슬로우모션을 촬영합니다."; }
      case 4: { Text.String = "연사"; Text1.String = "해상도와 프레임 레이트를 선택하여 연사로 촬영합니다."; }
      case 5: { Text.String = "사진"; Text1.String = "해상도와 프레임 레이트를 선택하여 사진을 촬영합니다."; }      
      default: { Text.String = "동영상"; Text1.String = "해상도와 프레임 레이트를 선택하여 동영상을 촬영합니다."; }
    } ;
    Application::Device.Mode = itemIndex;
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Bounds = <288,147,513,302>;
    preset Color = #00C8FFFF;
    preset Bitmap = Application::BlueBtn;
  }

  $rect <20,20,160,60>
  object Core::HorizontalList HorizontalList
  {
    preset StackingPriority = 0;
    preset Bounds = <0,165,800,285>;
    preset OnUpdate = SelectMode;
    preset OnLoadItem = OnLoadItem;
    preset Endless = true;
    preset SlideHandler = SlideTouchHandler;
    preset ScrollOffset = 0;
    preset SelectedItem = 0;
    preset ItemWidth = 160;
    preset NoOfItems = 6;
    preset ItemClass = Views::Image;
  }

  $rect <230,560,430,600>
  slot EnterMainView
  {
    if(Owner != null)
      Owner.DismissDialog( this, null, null, null, null, null, false );
    Application::Device.MainViewElement = true;  
  }

  $rect <230,480,430,520>
  object Core::Timer TouchTimer
  {
    preset OnTrigger = EnterMainView;
    preset Period = 0;
    preset Begin = 3000;
    preset Enabled = false;
  }

  $rect <230,520,430,560>
  slot RestartTimer
  {
    if ( TouchTimer.Enabled )
      TouchTimer.Enabled = false;
    TouchTimer.Enabled = true;
  }
}

$rect <1509,320,1709,360>
$output false
resource Resources::Bitmap BlueBtn
{
  attr bitmapfile FileName = .\Res\bluebtn (1).png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1749,280,1949,320>
$output false
resource Resources::Font MyFont
{
  attr fontname FontName = Noto Sans CJK KR;
  attr fontheight Height = 32;
  attr fontheightmode HeightMode = Popular;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xFF, 0xac00-0xd7a3;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = false;
  attr fontitalic Italic = false;
  attr fontkerning Kerning = true;
  attr fontrowdistance RowDistance;
}

$rect <1749,320,1949,360>
$output false
resource Resources::Font MyFont1
{
  attr fontname FontName = Noto Sans CJK KR;
  attr fontheight Height = 12;
  attr fontheightmode HeightMode = Popular;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xFF, 0xac00-0xd7a3;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = false;
  attr fontitalic Italic = false;
  attr fontkerning Kerning = true;
  attr fontrowdistance RowDistance;
}

$rect <1509,680,1709,720>
$output false
resource Resources::Bitmap camera
{
  attr bitmapfile FileName = .\Res\camera.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1509,720,1709,760>
$output false
resource Resources::Bitmap camcorder
{
  attr bitmapfile FileName = .\Res\camcorder (1).png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1509,760,1709,800>
$output false
resource Resources::Bitmap burst
{
  attr bitmapfile FileName = .\Res\burst.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1509,800,1709,840>
$output false
resource Resources::Bitmap timelapse
{
  attr bitmapfile FileName = .\Res\timelapse.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1509,840,1709,880>
$output false
resource Resources::Bitmap hyperlapse
{
  attr bitmapfile FileName = .\Res\hyperlapse.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1509,880,1709,920>
$output false
resource Resources::Bitmap slowmotion
{
  attr bitmapfile FileName = .\Res\slowmotion.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

// Bitmap resource containing diverse icons you can use in your project. The icons \
// have the size 36x36 pixel.
$rect <1509,920,1709,960>
$output false
resource Resources::Bitmap SymbolIconsMedium
{
  attr bitmapfile FileName = .\Res\ModeIcons2 (1).png;
  attr framesize FrameSize = <36,36>;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Alpha8;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1749,360,1949,400>
$output false
resource Resources::Font MyFont2
{
  attr fontname FontName = Noto Sans CJK KR;
  attr fontheight Height = 20;
  attr fontheightmode HeightMode = Popular;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xFF, 0xac00-0xd7a3;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = false;
  attr fontitalic Italic = false;
  attr fontkerning Kerning = true;
  attr fontrowdistance RowDistance;
}

$rect <1509,400,1709,440>
$output false
resource Resources::Bitmap BtnCapsule1
{
  attr bitmapfile FileName = .\Res\capsule_darkgray.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1509,440,1709,480>
$output false
resource Resources::Bitmap rectbtn
{
  attr bitmapfile FileName = .\Res\rectbtn (2).png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1509,80,1709,120>
inline Inline
{
  /*

    TO DO:

    Include external header files or add type and function declarations needed
    in the implementation of Application::DeviceClass1. For example:

      #include "DeviceDriver.h"

      #include "your_middleware_api.h"

      void Your_Middleware_Some_Function( int aSomeArg );

  */
}

$rect <1509,40,1709,80>
$output false
class DeviceClass : Templates::DeviceClass
{
  $rect <20,840,220,880>
  onset Grid
  {
    // The value doesn't change - nothing to do.
    if ( pure Grid == value )
      return;

    // Remember the property's new value.
    pure Grid = value;

    notifyobservers ^Grid;
  }

  $rect <20,0,220,40>
  property int32 Mode = 0;

  $rect <20,40,220,80>
  onset Mode
  {
    // The value doesn't change - nothing to do.
    if ( pure Mode == value )
      return;

    // Remember the property's new value.
    pure Mode = value;

    notifyobservers ^Mode;
  }

  $rect <20,149,220,189>
  property int32 VideoFrameRate = 0;

  $rect <20,189,220,229>
  onset VideoFrameRate
  {
    // The value doesn't change - nothing to do.
    if ( pure VideoFrameRate == value )
      return;

    // Remember the property's new value.
    pure VideoFrameRate = value;

    notifyobservers ^VideoFrameRate;
  }

  $rect <230,149,430,189>
  property int32 VideoResolution = 0;

  $rect <230,189,430,229>
  onset VideoResolution
  {
    // The value doesn't change - nothing to do.
    if ( pure VideoResolution == value )
      return;

    // Remember the property's new value.
    pure VideoResolution = value;

    notifyobservers ^VideoResolution;
  }

  $rect <20,229,220,269>
  property int32 VideoHDR = 0;

  $rect <20,269,220,309>
  onset VideoHDR
  {
    // The value doesn't change - nothing to do.
    if ( pure VideoHDR == value )
      return;

    // Remember the property's new value.
    pure VideoHDR = value;

    notifyobservers ^VideoHDR;
  }

  $rect <230,229,430,269>
  property int32 VideoRatio = 0;

  $rect <230,269,430,309>
  onset VideoRatio
  {
    // The value doesn't change - nothing to do.
    if ( pure VideoRatio == value )
      return;

    // Remember the property's new value.
    pure VideoRatio = value;

    notifyobservers ^VideoRatio;
  }

  $rect <440,229,640,269>
  property int32 VideoTime = 0;

  $rect <440,269,640,309>
  onset VideoTime
  {
    // The value doesn't change - nothing to do.
    if ( pure VideoTime == value )
      return;

    // Remember the property's new value.
    pure VideoTime = value;

    notifyobservers ^VideoTime;
  }

  $rect <670,149,870,189>
  property int32 SMFrameRate = 0;

  $rect <670,189,870,229>
  onset SMFrameRate
  {
    // The value doesn't change - nothing to do.
    if ( pure SMFrameRate == value )
      return;

    // Remember the property's new value.
    pure SMFrameRate = value;

    notifyobservers ^SMFrameRate;
  }

  $rect <880,149,1080,189>
  property int32 SMResolution = 0;

  $rect <880,189,1080,229>
  onset SMResolution
  {
    // The value doesn't change - nothing to do.
    if ( pure SMResolution == value )
      return;

    // Remember the property's new value.
    pure SMResolution = value;

    notifyobservers ^SMResolution;
  }

  $rect <670,229,870,269>
  property int32 SMHDR = 0;

  $rect <670,269,870,309>
  onset SMHDR
  {
    // The value doesn't change - nothing to do.
    if ( pure SMHDR == value )
      return;

    // Remember the property's new value.
    pure SMHDR = value;

    notifyobservers ^SMHDR;
  }

  $rect <880,229,1080,269>
  property int32 SMRatio = 0;

  $rect <880,269,1080,309>
  onset SMRatio
  {
    // The value doesn't change - nothing to do.
    if ( pure SMRatio == value )
      return;

    // Remember the property's new value.
    pure SMRatio = value;

    notifyobservers ^SMRatio;
  }

  $rect <1090,229,1290,269>
  property int32 SMTime = 0;

  $rect <1090,269,1290,309>
  onset SMTime
  {
    // The value doesn't change - nothing to do.
    if ( pure SMTime == value )
      return;

    // Remember the property's new value.
    pure SMTime = value;

    notifyobservers ^SMTime;
  }

  $rect <20,339,220,379>
  property int32 TLDuration = 0;

  $rect <20,379,220,419>
  onset TLDuration
  {
    // The value doesn't change - nothing to do.
    if ( pure TLDuration == value )
      return;

    // Remember the property's new value.
    pure TLDuration = value;

    notifyobservers ^TLDuration;
  }

  $rect <20,419,220,459>
  property int32 TLHDR = 0;

  $rect <20,459,220,499>
  onset TLHDR
  {
    // The value doesn't change - nothing to do.
    if ( pure TLHDR == value )
      return;

    // Remember the property's new value.
    pure TLHDR = value;

    notifyobservers ^TLHDR;
  }

  $rect <230,419,430,459>
  property int32 TLRatio = 0;

  $rect <230,459,430,499>
  onset TLRatio
  {
    // The value doesn't change - nothing to do.
    if ( pure TLRatio == value )
      return;

    // Remember the property's new value.
    pure TLRatio = value;

    notifyobservers ^TLRatio;
  }

  $rect <230,339,430,379>
  property int32 TLTime = 0;

  $rect <230,379,430,419>
  onset TLTime
  {
    // The value doesn't change - nothing to do.
    if ( pure TLTime == value )
      return;

    // Remember the property's new value.
    pure TLTime = value;

    notifyobservers ^TLTime;
  }

  $rect <680,339,880,379>
  property int32 HLDuration = 0;

  $rect <680,379,880,419>
  onset HLDuration
  {
    // The value doesn't change - nothing to do.
    if ( pure HLDuration == value )
      return;

    // Remember the property's new value.
    pure HLDuration = value;

    notifyobservers ^HLDuration;
  }

  $rect <680,419,880,459>
  property int32 HLHDR = 0;

  $rect <680,459,880,499>
  onset HLHDR
  {
    // The value doesn't change - nothing to do.
    if ( pure HLHDR == value )
      return;

    // Remember the property's new value.
    pure HLHDR = value;

    notifyobservers ^HLHDR;
  }

  $rect <890,419,1090,459>
  property int32 HLRatio = 0;

  $rect <890,459,1090,499>
  onset HLRatio
  {
    // The value doesn't change - nothing to do.
    if ( pure HLRatio == value )
      return;

    // Remember the property's new value.
    pure HLRatio = value;

    notifyobservers ^HLRatio;
  }

  $rect <890,339,1090,379>
  property int32 HLTime = 0;

  $rect <890,379,1090,419>
  onset HLTime
  {
    // The value doesn't change - nothing to do.
    if ( pure HLTime == value )
      return;

    // Remember the property's new value.
    pure HLTime = value;

    notifyobservers ^HLTime;
  }

  $rect <20,539,220,579>
  property int32 BurstRate = 0;

  $rect <20,579,220,619>
  onset BurstRate
  {
    // The value doesn't change - nothing to do.
    if ( pure BurstRate == value )
      return;

    // Remember the property's new value.
    pure BurstRate = value;

    notifyobservers ^BurstRate;
  }

  $rect <20,619,220,659>
  property int32 BurstRatio = 0;

  $rect <20,659,220,699>
  onset BurstRatio
  {
    // The value doesn't change - nothing to do.
    if ( pure BurstRatio == value )
      return;

    // Remember the property's new value.
    pure BurstRatio = value;

    notifyobservers ^BurstRatio;
  }

  $rect <230,539,430,579>
  property int32 BurstTimer = 0;

  $rect <230,579,430,619>
  onset BurstTimer
  {
    // The value doesn't change - nothing to do.
    if ( pure BurstTimer == value )
      return;

    // Remember the property's new value.
    pure BurstTimer = value;

    notifyobservers ^BurstTimer;
  }

  $rect <230,619,430,659>
  property int32 BurstResolution = 0;

  $rect <230,659,430,699>
  onset BurstResolution
  {
    // The value doesn't change - nothing to do.
    if ( pure BurstResolution == value )
      return;

    // Remember the property's new value.
    pure BurstResolution = value;

    notifyobservers ^BurstResolution;
  }

  $rect <890,539,1090,579>
  property int32 PhotoRatio = 0;

  $rect <890,579,1090,619>
  onset PhotoRatio
  {
    // The value doesn't change - nothing to do.
    if ( pure PhotoRatio == value )
      return;

    // Remember the property's new value.
    pure PhotoRatio = value;

    notifyobservers ^PhotoRatio;
  }

  $rect <680,539,880,579>
  property int32 PhotoTimer = 0;

  $rect <680,579,880,619>
  onset PhotoTimer
  {
    // The value doesn't change - nothing to do.
    if ( pure PhotoTimer == value )
      return;

    // Remember the property's new value.
    pure PhotoTimer = value;

    notifyobservers ^PhotoTimer;
  }

  $rect <1100,539,1300,579>
  property int32 PhotoResolution = 0;

  $rect <1100,579,1300,619>
  onset PhotoResolution
  {
    // The value doesn't change - nothing to do.
    if ( pure PhotoResolution == value )
      return;

    // Remember the property's new value.
    pure PhotoResolution = value;

    notifyobservers ^PhotoResolution;
  }

  // SettingSpec
  note group Note
  {
    attr Bounds = <0,100,1340,729>;
  }

  $rect <20,800,220,840>
  property bool Grid = false;

  $rect <240,800,440,840>
  property bool QuickCapture = false;

  $rect <240,840,440,880>
  onset QuickCapture
  {
    // The value doesn't change - nothing to do.
    if ( pure QuickCapture == value )
      return;

    // Remember the property's new value.
    pure QuickCapture = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <460,800,660,840>
  property bool RotationLock = false;

  $rect <460,840,660,880>
  onset RotationLock
  {
    // The value doesn't change - nothing to do.
    if ( pure RotationLock == value )
      return;

    // Remember the property's new value.
    pure RotationLock = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  // QuickMenu
  note group Note1
  {
    attr Bounds = <0,749,1120,900>;
  }

  $rect <229,0,429,40>
  property bool MainViewElement = true;

  $rect <229,40,429,80>
  onset MainViewElement
  {
    // The value doesn't change - nothing to do.
    if ( pure MainViewElement == value )
      return;

    // Remember the property's new value.
    pure MainViewElement = value;

    notifyobservers ^MainViewElement;
  }

  $rect <680,800,880,840>
  property int32 Brightness = 100;

  $rect <680,840,880,880>
  onset Brightness
  {
    // The value doesn't change - nothing to do.
    if ( pure Brightness == value )
      return;

    // Remember the property's new value.
    pure Brightness = value;

    notifyobservers ^Brightness;
  }

  $rect <900,800,1100,840>
  property bool ScreenLock = false;

  $rect <900,840,1100,880>
  onset ScreenLock
  {
    // The value doesn't change - nothing to do.
    if ( pure ScreenLock == value )
      return;

    // Remember the property's new value.
    pure ScreenLock = value;

    notifyobservers ^ScreenLock;
  }

  // Setting
  note group Note2
  {
    attr Bounds = <0,929,1120,1349>;
  }

  $rect <60,989,260,1029>
  property int32 AutoPowerOff;

  $rect <60,1029,260,1069>
  onset AutoPowerOff
  {
    // The value doesn't change - nothing to do.
    if ( pure AutoPowerOff == value )
      return;

    // Remember the property's new value.
    pure AutoPowerOff = value;


  }

  $rect <269,989,469,1029>
  property int32 Language;

  $rect <269,1029,469,1069>
  onset Language
  {
    // The value doesn't change - nothing to do.
    if ( pure Language == value )
      return;

    // Remember the property's new value.
    pure Language = value;


  }

  $rect <60,1149,260,1189>
  property int32 Month;

  $rect <60,1189,260,1229>
  onset Month
  {
    // The value doesn't change - nothing to do.
    if ( pure Month == value )
      return;

    // Remember the property's new value.
    pure Month = value;
  }

  $rect <260,1149,460,1189>
  property int32 Day;

  $rect <260,1189,460,1229>
  onset Day
  {
    // The value doesn't change - nothing to do.
    if ( pure Day == value )
      return;

    // Remember the property's new value.
    pure Day = value;
  }

  $rect <460,1149,660,1189>
  property int32 Year;

  $rect <460,1189,660,1229>
  onset Year
  {
    // The value doesn't change - nothing to do.
    if ( pure Year == value )
      return;

    // Remember the property's new value.
    pure Year = value;
  }

  $rect <260,1238,460,1278>
  property int32 Minute;

  $rect <260,1278,460,1318>
  onset Minute
  {
    // The value doesn't change - nothing to do.
    if ( pure Minute == value )
      return;

    // Remember the property's new value.
    pure Minute = value;
  }

  $rect <60,1238,260,1278>
  property int32 Hour;

  $rect <60,1278,260,1318>
  onset Hour
  {
    // The value doesn't change - nothing to do.
    if ( pure Hour == value )
      return;

    // Remember the property's new value.
    pure Hour = value;
  }

  $rect <629,989,829,1029>
  property int32 Mic;

  $rect <629,1029,829,1069>
  onset Mic
  {
    // The value doesn't change - nothing to do.
    if ( pure Mic == value )
      return;

    // Remember the property's new value.
    pure Mic = value;
  }

  $rect <840,989,1040,1029>
  property int32 ExternalMic;

  $rect <840,1029,1040,1069>
  onset ExternalMic
  {
    // The value doesn't change - nothing to do.
    if ( pure ExternalMic == value )
      return;

    // Remember the property's new value.
    pure ExternalMic = value;
  }

  $rect <789,1149,989,1189>
  property int32 Wifi;

  $rect <789,1189,989,1229>
  onset Wifi
  {
    // The value doesn't change - nothing to do.
    if ( pure Wifi == value )
      return;

    // Remember the property's new value.
    pure Wifi = value;
  }

  // Parameter
  note group Note3
  {
    attr Bounds = <0,1380,1120,1720>;
  }

  $rect <40,1469,240,1509>
  property int32 AutoColorRecipe;

  $rect <40,1509,240,1549>
  onset AutoColorRecipe
  {
    // The value doesn't change - nothing to do.
    if ( pure AutoColorRecipe == value )
      return;

    // Remember the property's new value.
    pure AutoColorRecipe = value;


  }

  $rect <249,1469,449,1509>
  property int32 AutoEV = 9;

  $rect <249,1509,449,1549>
  onset AutoEV
  {
    // The value doesn't change - nothing to do.
    if ( pure AutoEV == value )
      return;

    // Remember the property's new value.
    pure AutoEV = value;


  }

  $rect <459,1469,659,1509>
  property int32 AutoPhotometricMode;

  $rect <459,1509,659,1549>
  onset AutoPhotometricMode
  {
    // The value doesn't change - nothing to do.
    if ( pure AutoPhotometricMode == value )
      return;

    // Remember the property's new value.
    pure AutoPhotometricMode = value;
  }

  $rect <670,1469,870,1509>
  property int32 AutoSharpness;

  $rect <670,1509,870,1549>
  onset AutoSharpness
  {
    // The value doesn't change - nothing to do.
    if ( pure AutoSharpness == value )
      return;

    // Remember the property's new value.
    pure AutoSharpness = value;
  }

  $rect <880,1469,1080,1509>
  property int32 AutoWhiteBalance;

  $rect <880,1509,1080,1549>
  onset AutoWhiteBalance
  {
    // The value doesn't change - nothing to do.
    if ( pure AutoWhiteBalance == value )
      return;

    // Remember the property's new value.
    pure AutoWhiteBalance = value;
  }

  $rect <40,1580,240,1620>
  property int32 ManualColorRecipe;

  $rect <40,1620,240,1660>
  onset ManualColorRecipe
  {
    // The value doesn't change - nothing to do.
    if ( pure ManualColorRecipe == value )
      return;

    // Remember the property's new value.
    pure ManualColorRecipe = value;


  }

  $rect <249,1580,449,1620>
  property int32 ManualShutterSpeed;

  $rect <249,1620,449,1660>
  onset ManualShutterSpeed
  {
    // The value doesn't change - nothing to do.
    if ( pure ManualShutterSpeed == value )
      return;

    // Remember the property's new value.
    pure ManualShutterSpeed = value;


  }

  $rect <459,1580,659,1620>
  property int32 ManualISO;

  $rect <459,1620,659,1660>
  onset ManualISO
  {
    // The value doesn't change - nothing to do.
    if ( pure ManualISO == value )
      return;

    // Remember the property's new value.
    pure ManualISO = value;
  }

  $rect <670,1580,870,1620>
  property int32 ManualSharpness;

  $rect <670,1620,870,1660>
  onset ManualSharpness
  {
    // The value doesn't change - nothing to do.
    if ( pure ManualSharpness == value )
      return;

    // Remember the property's new value.
    pure ManualSharpness = value;
  }

  $rect <880,1580,1080,1620>
  property int32 ManualWhiteBalance;

  $rect <880,1620,1080,1660>
  onset ManualWhiteBalance
  {
    // The value doesn't change - nothing to do.
    if ( pure ManualWhiteBalance == value )
      return;

    // Remember the property's new value.
    pure ManualWhiteBalance = value;
  }

  $reorder OnSetGrid 3
}

$rect <1509,0,1709,40>
autoobject Application::DeviceClass Device;

// Bitmap resource containing diverse icons you can use in your project. The icons \
// have the size 36x36 pixel.
$rect <1509,960,1709,1000>
$output false
resource Resources::Bitmap SymbolIconsLarge
{
  attr bitmapfile FileName = .\Res\ModeIcons3.png;
  attr framesize FrameSize = <72,72>;
  attr framedelay FrameDelay;
  attr bitmapformat Format = Alpha8;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <849,222,1049,262>
$output false
class Setting : Core::Group
{
  $rect <20,20,160,60>
  object Core::WipeTouchHandler WipeTouchHandler
  {
    preset Bounds = <0,0,800,450>;
    preset OnTop = EnterQuickMenu;
  }

  $rect <0,520,200,560>
  inherited property Bounds = <0,0,800,450>;

  $rect <240,520,440,560>
  slot EnterQuickMenu
  {
    if(Owner != null)
      Owner.DismissDialog( this, Effects::SlideRightCentered, null, null, null, null, false );
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,0,800,450>;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton4
  {
    preset Bounds = <0,0,75,71>;
    preset OnLeave = EnterQuickMenu;
    preset Label = "";
    preset Appearance = Application::PushButtonConfig;
  }

  $rect <20,20,160,60>
  object Views::Line Line2
  {
    preset Point2 = <22,37>;
    preset Point1 = <38,24>;
    preset Width = 5;
  }

  $rect <20,20,160,60>
  object Views::Line Line3
  {
    preset Point2 = <38,50>;
    preset Point1 = <22,37>;
    preset Width = 5;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <22,86,783,178>;
    preset OnPress = EnterConnect;
    preset Icon = Application::longbtn;
    preset Label = "연결";
    preset Appearance = Application::PushButtonConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton1
  {
    preset Bounds = <22,173,783,265>;
    preset OnPress = EnterDisplay;
    preset Icon = Application::longbtn;
    preset Label = "디스플레이";
    preset Appearance = Application::PushButtonConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton2
  {
    preset Bounds = <22,260,783,352>;
    preset OnPress = EnterRecord;
    preset Icon = Application::longbtn;
    preset Label = "촬영";
    preset Appearance = Application::PushButtonConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton3
  {
    preset Bounds = <22,347,783,439>;
    preset OnPress = EnterSystem;
    preset Icon = Application::longbtn;
    preset Label = "시스템";
    preset Appearance = Application::PushButtonConfig;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <352,0,452,71>;
    preset String = "설정";
    preset Font = Application::MyFont;
  }

  $rect <240,560,440,600>
  slot EnterConnect
  {
    PresentDialog( ConnectSetting, Effects::SlideLeftCentered, null, null, null, null, null, null, null, false );
  }

  $rect <240,600,440,640>
  slot EnterDisplay
  {
    PresentDialog( DisplaySetting, Effects::SlideLeftCentered, null, null, null, null, null, null, null, false );
  }

  $rect <240,640,440,680>
  slot EnterRecord
  {
    PresentDialog( RecordSetting, Effects::SlideLeftCentered, null, null, null, null, null, null, null, false );
  }

  $rect <240,680,440,720>
  slot EnterSystem
  {
    PresentDialog( SystemSetting, Effects::SlideLeftCentered, null, null, null, null, null, null, null, false );
  }

  $rect <20,20,160,60>
  object Application::ConnectSetting ConnectSetting
  {
    preset Bounds = <800,0,1600,450>;
  }

  $rect <20,20,160,60>
  object Application::DisplaySetting DisplaySetting
  {
    preset Bounds = <800,0,1600,450>;
  }

  $rect <20,20,160,60>
  object Application::RecordSetting RecordSetting
  {
    preset Bounds = <800,0,1600,450>;
  }

  $rect <20,20,160,60>
  object Application::SystemSetting SystemSetting
  {
    preset Bounds = <800,0,1600,450>;
  }

  $reorder WipeTouchHandler 101
}

$rect <1509,520,1709,560>
$output false
resource Resources::Bitmap longbtn
{
  attr bitmapfile FileName = .\Res\listbtn2.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1509,560,1709,600>
$output false
resource Resources::Bitmap BtnCapsule2
{
  attr bitmapfile FileName = .\Res\btn1015 (1).png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1118,420,1318,460>
$output false
class HDRSetting : Core::Group
{
  $rect <249,560,449,600>
  slot SetHDR
  {
    var int32 centerPosition = 400;

    var int32 i;

    for (i = 0; i < HorizontalList.NoOfItems; i++){
      var Views::Text itemView = (Views::Text)HorizontalList.GetViewForItem(i);

      if (itemView != null){
          var int32 itemCenter = itemView.Bounds.x1 + (itemView.Bounds.w / 2);

          var int32 distanceFromCenter = itemCenter - centerPosition;

          if (distanceFromCenter >= -20 && distanceFromCenter <= 20){
              itemView.Color = #77CCFFFF;

              switch(Application::Device.Mode) {
                case 0: {Application::Device.VideoHDR = i;}
                case 1: {Application::Device.TLHDR = i;}
                case 2: {Application::Device.HLHDR = i;}
                case 3: {Application::Device.SMHDR = i;}
                default: ;
              }
          }
          else{
              itemView.Color = #FFFFFFFF;
          }
      }
    }
  }

  $rect <10,480,210,520>
  inherited property Bounds = <0,0,800,450>;

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,0,800,450>;
    preset Color = #22222298;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle1
  {
    preset Bounds = <0,250,800,450>;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Core::WipeTouchHandler WipeTouchHandler
  {
    preset Bounds = <0,0,800,297>;
    preset OnBottom = EnterSettingSpec;
  }

  $rect <20,20,160,60>
  object Views::Line Line
  {
    preset Point2 = <450,266>;
    preset Point1 = <350,266>;
    preset Width = 5;
  }

  $rect <250,480,450,520>
  slot EnterSettingSpec
  {
    if(Owner != null)
      Owner.DismissDialog( this, Effects::SlideDownCentered, null, null, null, null, false );
  }

  $rect <20,20,160,60>
  object Core::HorizontalList HorizontalList
  {
    preset Bounds = <0,350,800,450>;
    preset Focus = null;
    preset OnUpdate = SetHDR;
    preset OnLoadItem = OnLoadItem;
    preset PaddingRight = 330;
    preset SlideHandler = SlideTouchHandler;
    preset ScrollOffset = 0;
    preset SelectedItem = 0;
    preset PaddingLeft = 320;
    preset ItemWidth = 150;
    preset NoOfItems = 2;
    preset ItemClass = Views::Text;
  }

  // This method is called by 'HorizontalList' every time the list loads or updates \
  // an item.
  $rect <250,520,450,560>
  slot OnLoadItem
  {
    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = HorizontalList.Item;
    var Views::Text itemView = (Views::Text)HorizontalList.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( itemView == null )
      return;


    array string myItem[2];
    myItem[0] = "ON";
    myItem[1] = "OFF";

    // Configure the item view ...
    itemView.String = myItem[itemNo];
    itemView.Font   = Resources::FontLarge;
    itemView.Color  = #FFFFFFFF;

    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    itemView.Bounds.size = point( HorizontalList.ItemWidth, HorizontalList.Bounds.h );
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <274,297,526,338>;
    preset String = "HDR 안정화";
    preset Font = Application::MyFont;
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler
  {
    preset Bounds = <0,350,800,450>;
    preset SnapNext = <150,0>;
  }

  $reorder SetHDR 101
}

$rect <1118,460,1318,500>
$output false
class RatioSetting : Core::Group
{
  $rect <10,480,210,520>
  inherited property Bounds = <0,0,800,450>;

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,0,800,450>;
    preset Color = #22222298;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle1
  {
    preset Bounds = <0,250,800,450>;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Core::WipeTouchHandler WipeTouchHandler
  {
    preset Bounds = <0,0,800,297>;
    preset OnBottom = EnterSettingSpec;
  }

  $rect <20,20,160,60>
  object Views::Line Line
  {
    preset Point2 = <450,266>;
    preset Point1 = <350,266>;
    preset Width = 5;
  }

  $rect <250,480,450,520>
  slot EnterSettingSpec
  {
    if(Owner != null)
      Owner.DismissDialog( this, Effects::SlideDownCentered, null, null, null, null, false );
  }

  $rect <20,20,160,60>
  object Core::HorizontalList HorizontalList
  {
    preset Bounds = <0,350,800,450>;
    preset Focus = null;
    preset OnUpdate = SetRatio;
    preset OnLoadItem = OnLoadItem;
    preset PaddingRight = 330;
    preset SlideHandler = SlideTouchHandler;
    preset ScrollOffset = 0;
    preset SelectedItem = 0;
    preset PaddingLeft = 320;
    preset ItemWidth = 150;
    preset NoOfItems = 2;
    preset ItemClass = Views::Text;
  }

  // This method is called by 'HorizontalList' every time the list loads or updates \
  // an item.
  $rect <250,520,450,560>
  slot OnLoadItem
  {
    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = HorizontalList.Item;
    var Views::Text itemView = (Views::Text)HorizontalList.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( itemView == null )
      return;


    array string myItem[2];
    myItem[0] = "16:9";
    myItem[1] = "4:3";

    // Configure the item view ...
    itemView.String = myItem[itemNo];
    itemView.Font   = Resources::FontLarge;
    itemView.Color  = #FFFFFFFF;

    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    itemView.Bounds.size = point( HorizontalList.ItemWidth, HorizontalList.Bounds.h );
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <274,297,526,338>;
    preset String = "비율";
    preset Font = Application::MyFont;
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler
  {
    preset Bounds = <0,350,800,450>;
    preset SnapNext = <150,0>;
  }

  $rect <249,560,449,600>
  slot SetRatio
  {
    var int32 centerPosition = 400;

    var int32 i;

    for (i = 0; i < HorizontalList.NoOfItems; i++){
      var Views::Text itemView = (Views::Text)HorizontalList.GetViewForItem(i);

      if (itemView != null){
          var int32 itemCenter = itemView.Bounds.x1 + (itemView.Bounds.w / 2);

          var int32 distanceFromCenter = itemCenter - centerPosition;

          if (distanceFromCenter >= -20 && distanceFromCenter <= 20){
              itemView.Color = #77CCFFFF;
              switch(Application::Device.Mode) {
                case 0: {Application::Device.VideoRatio = i;}
                case 1: {Application::Device.TLRatio = i;}
                case 2: {Application::Device.HLRatio = i;}
                case 3: {Application::Device.SMRatio = i;}
                case 4: {Application::Device.BurstRatio = i;}
                case 5: {Application::Device.PhotoRatio = i;}
                default: ;
              }
          }
          else{
              itemView.Color = #FFFFFFFF;
          }
      }
    }
  }
}

$rect <1118,500,1318,540>
$output false
class TimeSetting : Core::Group
{
  $rect <10,480,210,520>
  inherited property Bounds = <0,0,800,450>;

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,0,800,450>;
    preset Color = #22222298;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle1
  {
    preset Bounds = <0,250,800,450>;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Core::WipeTouchHandler WipeTouchHandler
  {
    preset Bounds = <0,0,800,297>;
    preset OnBottom = EnterSettingSpec;
  }

  $rect <20,20,160,60>
  object Views::Line Line
  {
    preset Point2 = <450,266>;
    preset Point1 = <350,266>;
    preset Width = 5;
  }

  $rect <250,480,450,520>
  slot EnterSettingSpec
  {
    if(Owner != null)
      Owner.DismissDialog( this, Effects::SlideDownCentered, null, null, null, null, false );
  }

  $rect <20,20,160,60>
  object Core::HorizontalList HorizontalList
  {
    preset Bounds = <0,350,800,450>;
    preset Focus = null;
    preset OnUpdate = SetTime;
    preset OnLoadItem = OnLoadItem;
    preset PaddingRight = 330;
    preset SlideHandler = SlideTouchHandler;
    preset ScrollOffset = 0;
    preset SelectedItem = 0;
    preset PaddingLeft = 320;
    preset ItemWidth = 150;
    preset NoOfItems = 14;
    preset ItemClass = Views::Text;
  }

  // This method is called by 'HorizontalList' every time the list loads or updates \
  // an item.
  $rect <250,520,450,560>
  slot OnLoadItem
  {
    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = HorizontalList.Item;
    var Views::Text itemView = (Views::Text)HorizontalList.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( itemView == null )
      return;


    array string myItem[14];
    myItem[0] = "무한";
    myItem[1] = "15s";
    myItem[2] = "30s";
    myItem[3] = "1m";
    myItem[4] = "3m";
    myItem[5] = "5m";
    myItem[6] = "10m";
    myItem[7] = "15m";
    myItem[8] = "30m";
    myItem[9] = "1h";
    myItem[10] = "2h";
    myItem[11] = "3h";
    myItem[12] = "5h";
    myItem[13] = "10h";

    // Configure the item view ...
    itemView.String = myItem[itemNo];
    itemView.Font   = Application::MyFont2;
    itemView.Color  = #FFFFFFFF;

    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    itemView.Bounds.size = point( HorizontalList.ItemWidth, HorizontalList.Bounds.h );
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <274,297,526,338>;
    preset String = "촬영 길이";
    preset Font = Application::MyFont;
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler
  {
    preset Bounds = <0,350,800,450>;
    preset SnapNext = <150,0>;
  }

  $rect <249,560,449,600>
  slot SetTime
  {
    var int32 centerPosition = 400;

    var int32 i;

    for (i = 0; i < HorizontalList.NoOfItems; i++){
      var Views::Text itemView = (Views::Text)HorizontalList.GetViewForItem(i);

      if (itemView != null){
          var int32 itemCenter = itemView.Bounds.x1 + (itemView.Bounds.w / 2);

          var int32 distanceFromCenter = itemCenter - centerPosition;

          if (distanceFromCenter >= -20 && distanceFromCenter <= 20){
              itemView.Color = #77CCFFFF;
              
              switch(Application::Device.Mode) {
                case 0: {Application::Device.VideoTime = i;}
                case 1: {Application::Device.TLTime = i;}
                case 2: {Application::Device.HLTime = i;}
                case 3: {Application::Device.SMTime = i;}
                default: ;
              }
          }
          else{
              itemView.Color = #FFFFFFFF;
          }
      }
    }
  }
}

$rect <1509,160,1749,200>
$output false
autoobject WidgetSet::PushButtonConfig PushButtonConfig1
{
  preset LabelColorActive = #FFFFFFFF;
  preset LabelColorFocused = #FFFFFFFF;
  preset LabelColorDisabled = #FFFFFFFF;
  preset LabelColorDefault = #FFFFFFFF;
  preset LabelMarginLeft = 50;
  preset LabelAlignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
  preset LabelFont = Application::MyFont2;
  preset FaceLayout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
  preset FaceDefault = null;
}

$rect <1118,271,1318,311>
$output false
class TLSpec : Core::Group
{
  $rect <10,490,210,530>
  inherited property Bounds = <0,0,800,449>;

  $rect <10,530,210,570>
  slot EnterMainView
  {
    if(Owner != null)
      Owner.DismissDialog( this, Effects::SlideDownCentered, null, null, null, null, false );
    Application::Device.MainViewElement = true;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,0,800,450>;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Core::WipeTouchHandler WipeTouchHandler
  {
    preset Bounds = <0,0,800,450>;
    preset OnBottom = EnterMainView;
    preset OnLeft = null;
  }

  $rect <20,20,160,60>
  object Views::Line Line
  {
    preset Point2 = <450,17>;
    preset Point1 = <350,17>;
    preset Width = 5;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <274,28,526,69>;
    preset String = "타임랩스";
    preset Font = Application::MyFont;
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler
  {
    preset Bounds = <0,128,800,225>;
    preset SnapNext = <150,0>;
  }

  $rect <20,20,160,60>
  object Core::HorizontalList HorizontalList
  {
    preset Bounds = <0,128,800,225>;
    preset Focus = null;
    preset OnUpdate = SetTime;
    preset OnLoadItem = OnLoadItem;
    preset PaddingRight = 330;
    preset SlideHandler = SlideTouchHandler;
    preset ScrollOffset = 0;
    preset SelectedItem = 0;
    preset PaddingLeft = 320;
    preset ItemWidth = 150;
    preset NoOfItems = 4;
    preset ItemClass = Views::Text;
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler1
  {
    preset Bounds = <0,255,800,352>;
    preset SnapNext = <150,0>;
  }

  $rect <20,20,160,60>
  object Core::HorizontalList HorizontalList1
  {
    preset Bounds = <0,255,800,352>;
    preset Focus = null;
    preset OnUpdate = SetDuration;
    preset OnLoadItem = OnLoadItem1;
    preset PaddingRight = 330;
    preset SlideHandler = SlideTouchHandler1;
    preset ScrollOffset = 0;
    preset SelectedItem = 0;
    preset PaddingLeft = 320;
    preset ItemWidth = 150;
    preset NoOfItems = 4;
    preset ItemClass = Views::Text;
  }

  $rect <229,529,429,569>
  slot SetDuration
  {
    var int32 centerPosition = 400;

    var int32 i;

    for (i = 0; i < HorizontalList1.NoOfItems; i++){
      var Views::Text itemView = (Views::Text)HorizontalList1.GetViewForItem(i);

      if (itemView != null){
          var int32 itemCenter = itemView.Bounds.x1 + (itemView.Bounds.w / 2);

          var int32 distanceFromCenter = itemCenter - centerPosition;

          if (distanceFromCenter >= -20 && distanceFromCenter <= 20){
              itemView.Color = #77CCFFFF;
              Application::Device.TLDuration = i;
          }
          else{
              itemView.Color = #FFFFFFFF;
          }
      }
    }
  }

  $rect <229,489,429,529>
  slot SetTime
  {
    var int32 centerPosition = 400;

    var int32 i;

    for (i = 0; i < HorizontalList.NoOfItems; i++){
      var Views::Text itemView = (Views::Text)HorizontalList.GetViewForItem(i);

      // 아이템이 현재 화면에 보이는 경우에만
      if (itemView != null){
          // 아이템의 현재 위치 계산 (아이템의 왼쪽 상단 X좌표 + 아이템 너비 / 2)
          var int32 itemCenter = itemView.Bounds.x1 + (itemView.Bounds.w / 2);

          // 중앙 위치와 아이템 중심 위치의 차이 계산
          var int32 distanceFromCenter = itemCenter - centerPosition;

          // 중앙에 가까운 아이템은 색상을 하늘색으로, 나머지는 하얀색으로
          if (distanceFromCenter >= -20 && distanceFromCenter <= 20){
              itemView.Color = #77CCFFFF;  // 하늘색
              Application::Device.TLTime = i;
          }
          else{
              itemView.Color = #FFFFFFFF;  // 기본 하얀색
          }
      }
    }
  }

  $rect <830,30,1030,70>
  property int32 Mode;

  $rect <830,70,1030,110>
  onset Mode
  {
    // The value doesn't change - nothing to do.
    if ( pure Mode == value )
      return;

    // Remember the property's new value.
    pure Mode = value;

    switch(value){ 
      case 1: { Text.String = "타임랩스"; }
      case 2: { Text.String = "하이퍼랩스"; }
      case 3: { Text.String = "슬로우모션"; }
      case 4: { Text.String = "연사"; }
      case 5: { Text.String = "사진"; }      
      default: { Text.String = "동영상"; }
    } ;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton HDR
  {
    preset Bounds = <161,364,379,436>;
    preset OnPress = EnterHDRSetting;
    preset Label = "HDR ON";
    preset Appearance = Application::PushButtonConfig1;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Ratio
  {
    preset Bounds = <421,364,639,436>;
    preset OnPress = EnterRatioSetting;
    preset Label = "16:9";
    preset Appearance = Application::PushButtonConfig1;
  }

  $rect <670,490,870,530>
  slot EnterHDRSetting
  {
    PresentDialog( HDRSetting, Effects::SlideUpCentered, null, null, null, null, null, null, null, false );
    HDRSetting.HorizontalList.ScrollOffset = -160 * Application::Device.TLHDR;
  }

  $rect <20,20,160,60>
  object Application::HDRSetting HDRSetting
  {
    preset Bounds = <0,450,800,900>;
  }

  $rect <-220,360,-20,400>
  object Core::PropertyObserver HDRObserver
  {
    preset OnEvent = onEvent;
    preset Outlet = ^Application::Device.TLHDR;
  }

  // This slot method is executed when the associated property observer 'PropertyObserver' \
  // is notified.
  $rect <-220,400,-20,440>
  slot onEvent
  {
    if( Application::Device.TLHDR == 1 )
      HDR.Label = "HDR OFF";
    else HDR.Label = "HDR ON";
  }

  $rect <669,529,869,569>
  slot EnterRatioSetting
  {
    PresentDialog( RatioSetting, Effects::SlideUpCentered, null, null, null, null, null, null, null, false );
    RatioSetting.HorizontalList.ScrollOffset = -160 * Application::Device.TLRatio;
  }

  $rect <-220,449,-20,489>
  object Core::PropertyObserver RatioObserver
  {
    preset OnEvent = onEvent1;
    preset Outlet = ^Application::Device.TLRatio;
  }

  // This slot method is executed when the associated property observer 'PropertyObserver' \
  // is notified.
  $rect <-220,489,-20,529>
  slot onEvent1
  {
    if( Application::Device.TLRatio == 0 )
      Ratio.Label = "16:9";
    else Ratio.Label = "4:3";
  }

  $rect <20,20,160,60>
  object Application::RatioSetting RatioSetting
  {
    preset Bounds = <0,449,800,899>;
  }

  $rect <20,20,160,60>
  object Application::TimeSetting TimeSetting
  {
    preset Bounds = <0,449,800,899>;
  }

  // This method is called by 'HorizontalList' every time the list loads or updates \
  // an item.
  $rect <449,489,649,529>
  slot OnLoadItem
  {
    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = HorizontalList.Item;
    var Views::Text itemView = (Views::Text)HorizontalList.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( itemView == null )
      return;


    array string myItem[11];
    myItem[0] = "무한";
    myItem[1] = "3m";
    myItem[2] = "5m";
    myItem[3] = "10m";
    myItem[4] = "15m";
    myItem[5] = "30m";
    myItem[6] = "1h";
    myItem[7] = "2h";
    myItem[8] = "3h";
    myItem[9] = "5h";
    myItem[10] = "10h";

    // Configure the item view ...
    itemView.String = myItem[itemNo];
    itemView.Font   = Application::MyFont2;
    itemView.Color  = #FFFFFFFF;

    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    itemView.Bounds.size = point( HorizontalList.ItemWidth, HorizontalList.Bounds.h );
  }

  // This method is called by 'HorizontalList' every time the list loads or updates \
  // an item.
  $rect <449,529,649,569>
  slot OnLoadItem1
  {
    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = HorizontalList1.Item;
    var Views::Text itemView = (Views::Text)HorizontalList1.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( itemView == null )
      return;


    array string myItem[8];
    myItem[0] = "0.5s";
    myItem[1] = "1s";
    myItem[2] = "2s";
    myItem[3] = "5s";
    myItem[4] = "10s";
    myItem[5] = "30s";
    myItem[6] = "60s";
    myItem[7] = "120s";

    // Configure the item view ...
    itemView.String = myItem[itemNo];
    itemView.Font   = Application::MyFont2;
    itemView.Color  = #FFFFFFFF;

    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    itemView.Bounds.size = point( HorizontalList.ItemWidth, HorizontalList.Bounds.h );
  }

  $rect <20,20,160,60>
  object Views::Text Text1
  {
    preset Bounds = <350,98,450,128>;
    preset String = "촬영 길이";
    preset Font = Application::MyFont2;
    preset Color = #565656FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text2
  {
    preset Bounds = <350,225,450,255>;
    preset String = "촬영 간격";
    preset Font = Application::MyFont2;
    preset Color = #565656FF;
  }
}

$rect <1118,191,1318,231>
$output false
class HLSpec : Core::Group
{
  $rect <10,490,210,530>
  inherited property Bounds = <0,0,800,450>;

  $rect <10,530,210,570>
  slot EnterMainView
  {
    if(Owner != null)
      Owner.DismissDialog( this, Effects::SlideDownCentered, null, null, null, null, false );
    Application::Device.MainViewElement = true;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,0,800,450>;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Core::WipeTouchHandler WipeTouchHandler
  {
    preset Bounds = <0,0,800,450>;
    preset OnBottom = EnterMainView;
    preset OnLeft = null;
  }

  $rect <20,20,160,60>
  object Views::Line Line
  {
    preset Point2 = <450,17>;
    preset Point1 = <350,17>;
    preset Width = 5;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <274,28,526,69>;
    preset String = "하이퍼랩스";
    preset Font = Application::MyFont;
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler
  {
    preset Bounds = <0,128,800,225>;
    preset SnapNext = <150,0>;
  }

  $rect <20,20,160,60>
  object Core::HorizontalList HorizontalList
  {
    preset Bounds = <0,128,800,225>;
    preset Focus = null;
    preset OnUpdate = SetTime;
    preset OnLoadItem = OnLoadItem;
    preset PaddingRight = 330;
    preset SlideHandler = SlideTouchHandler;
    preset ScrollOffset = 0;
    preset SelectedItem = 0;
    preset PaddingLeft = 320;
    preset ItemWidth = 150;
    preset NoOfItems = 4;
    preset ItemClass = Views::Text;
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler1
  {
    preset Bounds = <0,255,800,352>;
    preset SnapNext = <150,0>;
  }

  $rect <20,20,160,60>
  object Core::HorizontalList HorizontalList1
  {
    preset Bounds = <0,255,800,352>;
    preset Focus = null;
    preset OnUpdate = SetDuration;
    preset OnLoadItem = OnLoadItem1;
    preset PaddingRight = 330;
    preset SlideHandler = SlideTouchHandler1;
    preset ScrollOffset = 0;
    preset SelectedItem = 0;
    preset PaddingLeft = 320;
    preset ItemWidth = 150;
    preset NoOfItems = 4;
    preset ItemClass = Views::Text;
  }

  $rect <830,30,1030,70>
  property int32 Mode;

  $rect <830,70,1030,110>
  onset Mode
  {
    // The value doesn't change - nothing to do.
    if ( pure Mode == value )
      return;

    // Remember the property's new value.
    pure Mode = value;

    switch(value){ 
      case 1: { Text.String = "타임랩스"; }
      case 2: { Text.String = "하이퍼랩스"; }
      case 3: { Text.String = "슬로우모션"; }
      case 4: { Text.String = "연사"; }
      case 5: { Text.String = "사진"; }      
      default: { Text.String = "동영상"; }
    } ;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton HDR
  {
    preset Bounds = <161,364,379,436>;
    preset OnPress = EnterHDRSetting;
    preset Label = "HDR ON";
    preset Appearance = Application::PushButtonConfig1;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Ratio
  {
    preset Bounds = <421,364,639,436>;
    preset OnPress = EnterRatioSetting;
    preset Label = "16:9";
    preset Appearance = Application::PushButtonConfig1;
  }

  $rect <670,490,870,530>
  slot EnterHDRSetting
  {
    PresentDialog( HDRSetting, Effects::SlideUpCentered, null, null, null, null, null, null, null, false );
    HDRSetting.HorizontalList.ScrollOffset = -160 * Application::Device.HLHDR;
  }

  $rect <20,20,160,60>
  object Application::HDRSetting HDRSetting
  {
    preset Bounds = <0,450,800,900>;
  }

  $rect <-220,360,-20,400>
  object Core::PropertyObserver HDRObserver
  {
    preset OnEvent = onEvent;
    preset Outlet = ^Application::Device.HLHDR;
  }

  // This slot method is executed when the associated property observer 'PropertyObserver' \
  // is notified.
  $rect <-220,400,-20,440>
  slot onEvent
  {
    if( Application::Device.HLHDR == 1 )
      HDR.Label = "HDR OFF";
    else HDR.Label = "HDR ON";
  }

  $rect <669,529,869,569>
  slot EnterRatioSetting
  {
    PresentDialog( RatioSetting, Effects::SlideUpCentered, null, null, null, null, null, null, null, false );
    RatioSetting.HorizontalList.ScrollOffset = -160 * Application::Device.HLRatio;
  }

  $rect <-220,449,-20,489>
  object Core::PropertyObserver RatioObserver
  {
    preset OnEvent = onEvent1;
    preset Outlet = ^Application::Device.HLRatio;
  }

  // This slot method is executed when the associated property observer 'PropertyObserver' \
  // is notified.
  $rect <-220,489,-20,529>
  slot onEvent1
  {
    if( Application::Device.HLRatio == 0 )
      Ratio.Label = "16:9";
    else Ratio.Label = "4:3";
  }

  $rect <20,20,160,60>
  object Application::RatioSetting RatioSetting
  {
    preset Bounds = <0,449,800,899>;
  }

  $rect <20,20,160,60>
  object Application::TimeSetting TimeSetting
  {
    preset Bounds = <0,449,800,899>;
  }

  $rect <229,529,429,569>
  slot SetDuration
  {
    var int32 centerPosition = 400;

    var int32 i;

    for (i = 0; i < HorizontalList1.NoOfItems; i++){
      var Views::Text itemView = (Views::Text)HorizontalList1.GetViewForItem(i);

      if (itemView != null){
          var int32 itemCenter = itemView.Bounds.x1 + (itemView.Bounds.w / 2);

          var int32 distanceFromCenter = itemCenter - centerPosition;

          if (distanceFromCenter >= -20 && distanceFromCenter <= 20){
              itemView.Color = #77CCFFFF;
              Application::Device.HLDuration = i;
          }
          else{
              itemView.Color = #FFFFFFFF;
          }
      }
    }
  }

  $rect <229,489,429,529>
  slot SetTime
  {
    var int32 centerPosition = 400;

    var int32 i;

    for (i = 0; i < HorizontalList.NoOfItems; i++){
      var Views::Text itemView = (Views::Text)HorizontalList.GetViewForItem(i);

      // 아이템이 현재 화면에 보이는 경우에만
      if (itemView != null){
          // 아이템의 현재 위치 계산 (아이템의 왼쪽 상단 X좌표 + 아이템 너비 / 2)
          var int32 itemCenter = itemView.Bounds.x1 + (itemView.Bounds.w / 2);

          // 중앙 위치와 아이템 중심 위치의 차이 계산
          var int32 distanceFromCenter = itemCenter - centerPosition;

          // 중앙에 가까운 아이템은 색상을 하늘색으로, 나머지는 하얀색으로
          if (distanceFromCenter >= -20 && distanceFromCenter <= 20){
              itemView.Color = #77CCFFFF;  // 하늘색
              Application::Device.HLTime = i;
          }
          else{
              itemView.Color = #FFFFFFFF;  // 기본 하얀색
          }
      }
    }
  }

  // This method is called by 'HorizontalList' every time the list loads or updates \
  // an item.
  $rect <449,489,649,529>
  slot OnLoadItem
  {
    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = HorizontalList.Item;
    var Views::Text itemView = (Views::Text)HorizontalList.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( itemView == null )
      return;


    array string myItem[11];
    myItem[0] = "무한";
    myItem[1] = "3m";
    myItem[2] = "5m";
    myItem[3] = "10m";
    myItem[4] = "15m";
    myItem[5] = "30m";
    myItem[6] = "1h";
    myItem[7] = "2h";
    myItem[8] = "3h";
    myItem[9] = "5h";
    myItem[10] = "10h";

    // Configure the item view ...
    itemView.String = myItem[itemNo];
    itemView.Font   = Application::MyFont2;
    itemView.Color  = #FFFFFFFF;

    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    itemView.Bounds.size = point( HorizontalList.ItemWidth, HorizontalList.Bounds.h );
  }

  // This method is called by 'HorizontalList' every time the list loads or updates \
  // an item.
  $rect <449,529,649,569>
  slot OnLoadItem1
  {
    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = HorizontalList1.Item;
    var Views::Text itemView = (Views::Text)HorizontalList1.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( itemView == null )
      return;


    array string myItem[8];
    myItem[0] = "0.5s";
    myItem[1] = "1s";
    myItem[2] = "2s";
    myItem[3] = "5s";
    myItem[4] = "10s";
    myItem[5] = "30s";
    myItem[6] = "60s";
    myItem[7] = "120s";

    // Configure the item view ...
    itemView.String = myItem[itemNo];
    itemView.Font   = Application::MyFont2;
    itemView.Color  = #FFFFFFFF;

    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    itemView.Bounds.size = point( HorizontalList.ItemWidth, HorizontalList.Bounds.h );
  }

  $rect <20,20,160,60>
  object Views::Text Text1
  {
    preset Bounds = <350,98,450,128>;
    preset String = "촬영 길이";
    preset Font = Application::MyFont2;
    preset Color = #565656FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text2
  {
    preset Bounds = <350,225,450,255>;
    preset String = "촬영 간격";
    preset Font = Application::MyFont2;
    preset Color = #565656FF;
  }
}

$rect <1118,311,1318,351>
$output false
class SMSpec : Core::Group
{
  $rect <10,490,210,530>
  inherited property Bounds = <0,0,800,450>;

  $rect <10,530,210,570>
  slot EnterMainView
  {
    if(Owner != null)
      Owner.DismissDialog( this, Effects::SlideDownCentered, null, null, null, null, false );
    Application::Device.MainViewElement = true;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,0,800,450>;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Core::WipeTouchHandler WipeTouchHandler
  {
    preset Bounds = <0,0,800,450>;
    preset OnBottom = EnterMainView;
    preset OnLeft = null;
  }

  $rect <20,20,160,60>
  object Views::Line Line
  {
    preset Point2 = <450,17>;
    preset Point1 = <350,17>;
    preset Width = 5;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <274,28,526,69>;
    preset String = "슬로우모션";
    preset Font = Application::MyFont;
  }

  // This method is called by 'HorizontalList' every time the list loads or updates \
  // an item.
  $rect <449,489,649,529>
  slot OnLoadItem
  {
    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = HorizontalList.Item;
    var Views::Text itemView = (Views::Text)HorizontalList.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( itemView == null )
      return;

    array string myItem[4];
    myItem[0] = "8K";
    myItem[1] = "4K";
    myItem[2] = "2.7K";
    myItem[3] = "1080P";

    // Configure the item view ...
    itemView.String = myItem[itemNo];
    itemView.Font   = Resources::FontMedium;
    itemView.Color  = #FFFFFFFF;


    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    itemView.Bounds.size = point( HorizontalList.ItemWidth, HorizontalList.Bounds.h );
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler
  {
    preset Bounds = <0,128,800,225>;
    preset SnapNext = <150,0>;
  }

  $rect <20,20,160,60>
  object Core::HorizontalList HorizontalList
  {
    preset Bounds = <0,128,800,225>;
    preset Focus = null;
    preset OnUpdate = SetResolution;
    preset OnLoadItem = OnLoadItem;
    preset PaddingRight = 330;
    preset SlideHandler = SlideTouchHandler;
    preset ScrollOffset = 0;
    preset SelectedItem = 0;
    preset PaddingLeft = 320;
    preset ItemWidth = 150;
    preset NoOfItems = 4;
    preset ItemClass = Views::Text;
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler1
  {
    preset Bounds = <0,255,800,352>;
    preset SnapNext = <150,0>;
  }

  $rect <20,20,160,60>
  object Core::HorizontalList HorizontalList1
  {
    preset Bounds = <0,255,800,352>;
    preset Focus = null;
    preset OnUpdate = SetFrameRate;
    preset OnLoadItem = OnLoadItem1;
    preset PaddingRight = 330;
    preset SlideHandler = SlideTouchHandler1;
    preset ScrollOffset = 0;
    preset SelectedItem = 0;
    preset PaddingLeft = 320;
    preset ItemWidth = 150;
    preset NoOfItems = 4;
    preset ItemClass = Views::Text;
  }

  // This method is called by 'HorizontalList' every time the list loads or updates \
  // an item.
  $rect <449,529,649,569>
  slot OnLoadItem1
  {
    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = HorizontalList1.Item;
    var Views::Text itemView = (Views::Text)HorizontalList1.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( itemView == null )
      return;


    array string myItem[6];
    myItem[0] = "60";
    myItem[1] = "50";
    myItem[2] = "48";
    myItem[3] = "30";
    myItem[4] = "25";
    myItem[5] = "24";

    // Configure the item view ...
    itemView.String = myItem[itemNo];
    itemView.Font   = Resources::FontMedium;
    itemView.Color  = #FFFFFFFF;

    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    itemView.Bounds.size = point( HorizontalList1.ItemWidth, HorizontalList1.Bounds.h );
  }

  $rect <20,20,160,60>
  object Views::Text Text1
  {
    preset Bounds = <350,98,450,128>;
    preset String = "해상도";
    preset Font = Application::MyFont2;
    preset Color = #565656FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text2
  {
    preset Bounds = <350,225,450,255>;
    preset String = "프레임";
    preset Font = Application::MyFont2;
    preset Color = #565656FF;
  }

  $rect <229,529,429,569>
  slot SetFrameRate
  {
    var int32 centerPosition = 400;

    var int32 i;

    for (i = 0; i < HorizontalList1.NoOfItems; i++){
      var Views::Text itemView = (Views::Text)HorizontalList1.GetViewForItem(i);

      if (itemView != null){
          var int32 itemCenter = itemView.Bounds.x1 + (itemView.Bounds.w / 2);

          var int32 distanceFromCenter = itemCenter - centerPosition;

          if (distanceFromCenter >= -20 && distanceFromCenter <= 20){
              itemView.Color = #77CCFFFF;
              Application::Device.SMFrameRate = i;
          }
          else{
              itemView.Color = #FFFFFFFF;
          }
      }
    }
  }

  $rect <229,489,429,529>
  slot SetResolution
  {
    var int32 centerPosition = 400;

    var int32 i;

    for (i = 0; i < HorizontalList.NoOfItems; i++){
      var Views::Text itemView = (Views::Text)HorizontalList.GetViewForItem(i);

      // 아이템이 현재 화면에 보이는 경우에만
      if (itemView != null){
          // 아이템의 현재 위치 계산 (아이템의 왼쪽 상단 X좌표 + 아이템 너비 / 2)
          var int32 itemCenter = itemView.Bounds.x1 + (itemView.Bounds.w / 2);

          // 중앙 위치와 아이템 중심 위치의 차이 계산
          var int32 distanceFromCenter = itemCenter - centerPosition;

          // 중앙에 가까운 아이템은 색상을 하늘색으로, 나머지는 하얀색으로
          if (distanceFromCenter >= -20 && distanceFromCenter <= 20){
              itemView.Color = #77CCFFFF;  // 하늘색
              Application::Device.SMResolution = i;
          }
          else{
              itemView.Color = #FFFFFFFF;  // 기본 하얀색
          }
      }
    }
  }

  $rect <830,30,1030,70>
  property int32 Mode;

  $rect <830,70,1030,110>
  onset Mode
  {
    // The value doesn't change - nothing to do.
    if ( pure Mode == value )
      return;

    // Remember the property's new value.
    pure Mode = value;

    switch(value){ 
      case 1: { Text.String = "타임랩스"; }
      case 2: { Text.String = "하이퍼랩스"; }
      case 3: { Text.String = "슬로우모션"; }
      case 4: { Text.String = "연사"; }
      case 5: { Text.String = "사진"; }      
      default: { Text.String = "동영상"; }
    } ;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton HDR
  {
    preset Bounds = <31,364,249,436>;
    preset OnPress = EnterHDRSetting;
    preset Label = "HDR ON";
    preset Appearance = Application::PushButtonConfig1;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Ratio
  {
    preset Bounds = <291,364,509,436>;
    preset OnPress = EnterRatioSetting;
    preset Label = "16:9";
    preset Appearance = Application::PushButtonConfig1;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Time
  {
    preset Bounds = <553,364,771,436>;
    preset OnPress = EnterTimeSetting;
    preset Label = "무한";
    preset Appearance = Application::PushButtonConfig1;
  }

  $rect <670,490,870,530>
  slot EnterHDRSetting
  {
    PresentDialog( HDRSetting, Effects::SlideUpCentered, null, null, null, null, null, null, null, false );
    HDRSetting.HorizontalList.ScrollOffset = -160 * Application::Device.SMHDR;
  }

  $rect <20,20,160,60>
  object Application::HDRSetting HDRSetting
  {
    preset Bounds = <0,450,800,900>;
  }

  $rect <-220,360,-20,400>
  object Core::PropertyObserver HDRObserver
  {
    preset OnEvent = onEvent;
    preset Outlet = ^Application::Device.SMHDR;
  }

  // This slot method is executed when the associated property observer 'PropertyObserver' \
  // is notified.
  $rect <-220,400,-20,440>
  slot onEvent
  {
    if( Application::Device.SMHDR == 1 )
      HDR.Label = "HDR OFF";
    else HDR.Label = "HDR ON";
  }

  $rect <669,529,869,569>
  slot EnterRatioSetting
  {
    PresentDialog( RatioSetting, Effects::SlideUpCentered, null, null, null, null, null, null, null, false );
    RatioSetting.HorizontalList.ScrollOffset = -160 * Application::Device.SMRatio;
  }

  $rect <669,569,869,609>
  slot EnterTimeSetting
  {
    PresentDialog( TimeSetting, Effects::SlideUpCentered, null, null, null, null, null, null, null, false );
    TimeSetting.HorizontalList.ScrollOffset = -160 * Application::Device.SMTime;
  }

  $rect <-220,449,-20,489>
  object Core::PropertyObserver RatioObserver
  {
    preset OnEvent = onEvent1;
    preset Outlet = ^Application::Device.SMRatio;
  }

  // This slot method is executed when the associated property observer 'PropertyObserver' \
  // is notified.
  $rect <-220,489,-20,529>
  slot onEvent1
  {
    if( Application::Device.SMRatio == 0 )
      Ratio.Label = "16:9";
    else Ratio.Label = "4:3";
  }

  $rect <-220,540,-20,580>
  object Core::PropertyObserver TimeObserver
  {
    preset OnEvent = onEvent2;
    preset Outlet = ^Application::Device.SMTime;
  }

  // This slot method is executed when the associated property observer 'PropertyObserver' \
  // is notified.
  $rect <-220,580,-20,620>
  slot onEvent2
  {
    array string myItem[12];
    myItem[0] = "무한";
    myItem[1] = "15s";
    myItem[2] = "30s";
    myItem[3] = "1m";
    myItem[4] = "3m";
    myItem[5] = "5m";
    myItem[6] = "10m";
    myItem[7] = "15m";
    myItem[8] = "30m";
    myItem[9] = "1h";
    myItem[10] = "2h";
    myItem[11] = "3h";

    Time.Label = myItem[Application::Device.SMTime];
  }

  $rect <20,20,160,60>
  object Application::RatioSetting RatioSetting
  {
    preset Bounds = <0,449,800,899>;
  }

  $rect <20,20,160,60>
  object Application::TimeSetting TimeSetting
  {
    preset Bounds = <0,449,800,899>;
  }
}

$rect <1118,231,1318,271>
$output false
class BurstSpec : Core::Group
{
  $rect <10,490,210,530>
  inherited property Bounds = <0,0,800,450>;

  $rect <10,530,210,570>
  slot EnterMainView
  {
    if(Owner != null)
      Owner.DismissDialog( this, Effects::SlideDownCentered, null, null, null, null, false );
    Application::Device.MainViewElement = true;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,0,800,450>;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Core::WipeTouchHandler WipeTouchHandler
  {
    preset Bounds = <0,0,800,450>;
    preset OnBottom = EnterMainView;
    preset OnLeft = null;
  }

  $rect <20,20,160,60>
  object Views::Line Line
  {
    preset Point2 = <450,17>;
    preset Point1 = <350,17>;
    preset Width = 5;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <274,28,526,69>;
    preset String = "연사";
    preset Font = Application::MyFont;
  }

  // This method is called by 'HorizontalList' every time the list loads or updates \
  // an item.
  $rect <449,489,649,529>
  slot OnLoadItem
  {
    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = HorizontalList.Item;
    var Views::Text itemView = (Views::Text)HorizontalList.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( itemView == null )
      return;


    array string myItem[5];
    myItem[0] = "없음";
    myItem[1] = "3s";
    myItem[2] = "5s";
    myItem[3] = "10s";
    myItem[4] = "15s";

    // Configure the item view ...
    itemView.String = myItem[itemNo];
    itemView.Font   = Application::MyFont2;
    itemView.Color  = #FFFFFFFF;

    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    itemView.Bounds.size = point( HorizontalList.ItemWidth, HorizontalList.Bounds.h );
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler
  {
    preset Bounds = <0,128,800,225>;
    preset SnapNext = <150,0>;
  }

  $rect <20,20,160,60>
  object Core::HorizontalList HorizontalList
  {
    preset Bounds = <0,128,800,225>;
    preset Focus = null;
    preset OnUpdate = SetTimer;
    preset OnLoadItem = OnLoadItem;
    preset PaddingRight = 330;
    preset SlideHandler = SlideTouchHandler;
    preset ScrollOffset = 0;
    preset SelectedItem = 0;
    preset PaddingLeft = 320;
    preset ItemWidth = 150;
    preset NoOfItems = 5;
    preset ItemClass = Views::Text;
  }

  $rect <20,20,160,60>
  object Views::Text Text1
  {
    preset Bounds = <350,98,450,128>;
    preset String = "타이머";
    preset Font = Application::MyFont2;
    preset Color = #565656FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text2
  {
    preset Bounds = <350,225,450,255>;
    preset String = "해상도";
    preset Font = Application::MyFont2;
    preset Color = #565656FF;
  }

  $rect <229,489,429,529>
  slot SetTimer
  {
    var int32 centerPosition = 400;

    var int32 i;

    for (i = 0; i < HorizontalList.NoOfItems; i++){
      var Views::Text itemView = (Views::Text)HorizontalList.GetViewForItem(i);

      // 아이템이 현재 화면에 보이는 경우에만
      if (itemView != null){
          // 아이템의 현재 위치 계산 (아이템의 왼쪽 상단 X좌표 + 아이템 너비 / 2)
          var int32 itemCenter = itemView.Bounds.x1 + (itemView.Bounds.w / 2);

          // 중앙 위치와 아이템 중심 위치의 차이 계산
          var int32 distanceFromCenter = itemCenter - centerPosition;

          // 중앙에 가까운 아이템은 색상을 하늘색으로, 나머지는 하얀색으로
          if (distanceFromCenter >= -20 && distanceFromCenter <= 20){
              itemView.Color = #77CCFFFF;  // 하늘색
              Application::Device.BurstTimer = i;
          }
          else{
              itemView.Color = #FFFFFFFF;  // 기본 하얀색
          }
      }
    }
  }

  $rect <830,30,1030,70>
  property int32 Mode;

  $rect <830,70,1030,110>
  onset Mode
  {
    // The value doesn't change - nothing to do.
    if ( pure Mode == value )
      return;

    // Remember the property's new value.
    pure Mode = value;

    switch(value){ 
      case 1: { Text.String = "타임랩스"; }
      case 2: { Text.String = "하이퍼랩스"; }
      case 3: { Text.String = "슬로우모션"; }
      case 4: { Text.String = "연사"; }
      case 5: { Text.String = "사진"; }      
      default: { Text.String = "동영상"; }
    } ;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Rate
  {
    preset Bounds = <161,364,379,436>;
    preset OnPress = EnterRateSetting;
    preset Label = "3p/1s";
    preset Appearance = Application::PushButtonConfig1;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Ratio
  {
    preset Bounds = <421,364,639,436>;
    preset OnPress = EnterRatioSetting;
    preset Label = "16:9";
    preset Appearance = Application::PushButtonConfig1;
  }

  $rect <669,489,869,529>
  slot EnterRateSetting
  {
    PresentDialog( HDRSetting, Effects::SlideUpCentered, null, null, null, null, null, null, null, false );
    RateSetting.HorizontalList.ScrollOffset = -160 * Application::Device.BurstRate;
  }

  $rect <20,20,160,60>
  object Application::HDRSetting HDRSetting
  {
    preset Bounds = <0,450,800,900>;
  }

  $rect <-220,360,-20,400>
  object Core::PropertyObserver RateObserver
  {
    preset OnEvent = onEvent;
    preset Outlet = ^Application::Device.BurstRate;
  }

  // This slot method is executed when the associated property observer 'PropertyObserver' \
  // is notified.
  $rect <-220,400,-20,440>
  slot onEvent
  {
    array string myItem[9];
    myItem[0] = "3p/1s";
    myItem[1] = "5p/1s";
    myItem[2] = "10p/1s";
    myItem[3] = "15p/1s";
    myItem[4] = "30p/1s";
    myItem[5] = "10p/3s";
    myItem[6] = "30p/3s";
    myItem[7] = "30p/6s";
    myItem[8] = "30p/10s";

    Rate.Label = myItem[Application::Device.BurstRate];
  }

  $rect <668,528,868,568>
  slot EnterRatioSetting
  {
    PresentDialog( RatioSetting, Effects::SlideUpCentered, null, null, null, null, null, null, null, false );
    RatioSetting.HorizontalList1.ScrollOffset = -160 * Application::Device.BurstRatio;
  }

  $rect <-220,449,-20,489>
  object Core::PropertyObserver RatioObserver
  {
    preset OnEvent = onEvent1;
    preset Outlet = ^Application::Device.BurstRatio;
  }

  // This slot method is executed when the associated property observer 'PropertyObserver' \
  // is notified.
  $rect <-220,489,-20,529>
  slot onEvent1
  {
    if( Application::Device.BurstRatio == 0 )
      Ratio.Label = "16:9";
    else Ratio.Label = "4:3";
  }

  $rect <20,20,160,60>
  object Application::RatioSetting RatioSetting
  {
    preset Bounds = <0,449,800,899>;
  }

  $rect <20,20,160,60>
  object Application::RateSetting RateSetting
  {
    preset Bounds = <0,449,800,899>;
  }

  $rect <20,20,160,60>
  object Views::Text Text3
  {
    preset Bounds = <323,255,477,352>;
    preset String = "12MP";
    preset Font = Application::MyFont2;
    preset Color = #77CCFFFF;
  }
}

$rect <1118,351,1318,391>
$output false
class PhotoSpec : Core::Group
{
  $rect <10,490,210,530>
  inherited property Bounds = <0,0,800,450>;

  $rect <10,530,210,570>
  slot EnterMainView
  {
    if(Owner != null)
      Owner.DismissDialog( this, Effects::SlideDownCentered, null, null, null, null, false );
    Application::Device.MainViewElement = true;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,0,800,450>;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Core::WipeTouchHandler WipeTouchHandler
  {
    preset Bounds = <0,0,800,450>;
    preset OnBottom = EnterMainView;
    preset OnLeft = null;
  }

  $rect <20,20,160,60>
  object Views::Line Line
  {
    preset Point2 = <450,17>;
    preset Point1 = <350,17>;
    preset Width = 5;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <274,28,526,69>;
    preset String = "사진";
    preset Font = Application::MyFont;
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler
  {
    preset Bounds = <0,128,800,225>;
    preset SnapNext = <150,0>;
  }

  $rect <20,20,160,60>
  object Core::HorizontalList HorizontalList
  {
    preset Bounds = <0,128,800,225>;
    preset Focus = null;
    preset OnUpdate = SetResolution;
    preset OnLoadItem = OnLoadItem;
    preset PaddingRight = 330;
    preset SlideHandler = SlideTouchHandler;
    preset ScrollOffset = 0;
    preset SelectedItem = 0;
    preset PaddingLeft = 320;
    preset ItemWidth = 150;
    preset NoOfItems = 5;
    preset ItemClass = Views::Text;
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler1
  {
    preset Bounds = <0,255,800,352>;
    preset SnapNext = <150,0>;
  }

  $rect <20,20,160,60>
  object Core::HorizontalList HorizontalList1
  {
    preset Bounds = <0,255,800,352>;
    preset Focus = null;
    preset OnUpdate = SetTimer;
    preset OnLoadItem = OnLoadItem1;
    preset PaddingRight = 330;
    preset SlideHandler = SlideTouchHandler1;
    preset ScrollOffset = 0;
    preset SelectedItem = 0;
    preset PaddingLeft = 320;
    preset ItemWidth = 150;
    preset NoOfItems = 2;
    preset ItemClass = Views::Text;
  }

  $rect <20,20,160,60>
  object Views::Text Text1
  {
    preset Bounds = <350,98,450,128>;
    preset String = "타이머";
    preset Font = Application::MyFont2;
    preset Color = #565656FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text2
  {
    preset Bounds = <350,225,450,255>;
    preset String = "해상도";
    preset Font = Application::MyFont2;
    preset Color = #565656FF;
  }

  $rect <230,570,430,610>
  slot SetTimer
  {
    var int32 centerPosition = 400;

    var int32 i;

    for (i = 0; i < HorizontalList.NoOfItems; i++){
      var Views::Text itemView = (Views::Text)HorizontalList1.GetViewForItem(i);

      if (itemView != null){
          var int32 itemCenter = itemView.Bounds.x1 + (itemView.Bounds.w / 2);

          var int32 distanceFromCenter = itemCenter - centerPosition;

          if (distanceFromCenter >= -20 && distanceFromCenter <= 20){
              itemView.Color = #77CCFFFF;
              Application::Device.PhotoTimer = i;
          }
          else{
              itemView.Color = #FFFFFFFF;
          }
      }
    }
  }

  $rect <230,530,430,570>
  slot SetResolution
  {
    var int32 centerPosition = 400;

    var int32 i;

    for (i = 0; i < HorizontalList1.NoOfItems; i++){
      var Views::Text itemView = (Views::Text)HorizontalList.GetViewForItem(i);

      // 아이템이 현재 화면에 보이는 경우에만
      if (itemView != null){
          // 아이템의 현재 위치 계산 (아이템의 왼쪽 상단 X좌표 + 아이템 너비 / 2)
          var int32 itemCenter = itemView.Bounds.x1 + (itemView.Bounds.w / 2);

          // 중앙 위치와 아이템 중심 위치의 차이 계산
          var int32 distanceFromCenter = itemCenter - centerPosition;

          // 중앙에 가까운 아이템은 색상을 하늘색으로, 나머지는 하얀색으로
          if (distanceFromCenter >= -20 && distanceFromCenter <= 20){
              itemView.Color = #77CCFFFF;  // 하늘색
              Application::Device.PhotoResolution = i;
          }
          else{
              itemView.Color = #FFFFFFFF;  // 기본 하얀색
          }
      }
    }
  }

  $rect <830,30,1030,70>
  property int32 Mode;

  $rect <830,70,1030,110>
  onset Mode
  {
    // The value doesn't change - nothing to do.
    if ( pure Mode == value )
      return;

    // Remember the property's new value.
    pure Mode = value;

    switch(value){ 
      case 1: { Text.String = "타임랩스"; }
      case 2: { Text.String = "하이퍼랩스"; }
      case 3: { Text.String = "슬로우모션"; }
      case 4: { Text.String = "연사"; }
      case 5: { Text.String = "사진"; }      
      default: { Text.String = "동영상"; }
    } ;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton Ratio
  {
    preset Bounds = <291,364,509,436>;
    preset OnPress = EnterRatioSetting;
    preset Label = "16:9";
    preset Appearance = Application::PushButtonConfig1;
  }

  $rect <20,20,160,60>
  object Application::HDRSetting HDRSetting
  {
    preset Bounds = <0,450,800,900>;
  }

  $rect <669,529,869,569>
  slot EnterRatioSetting
  {
    PresentDialog( RatioSetting, Effects::SlideUpCentered, null, null, null, null, null, null, null, false );
    RatioSetting.HorizontalList.ScrollOffset = -160 * Application::Device.PhotoRatio;
  }

  $rect <-220,449,-20,489>
  object Core::PropertyObserver RatioObserver
  {
    preset OnEvent = onEvent1;
    preset Outlet = ^Application::Device.VideoRatio;
  }

  // This slot method is executed when the associated property observer 'PropertyObserver' \
  // is notified.
  $rect <-220,489,-20,529>
  slot onEvent1
  {
    if( Application::Device.VideoRatio == 0 )
      Ratio.Label = "16:9";
    else Ratio.Label = "4:3";
  }

  $rect <20,20,160,60>
  object Application::RatioSetting RatioSetting
  {
    preset Bounds = <0,449,800,899>;
  }

  $rect <20,20,160,60>
  object Application::TimeSetting TimeSetting
  {
    preset Bounds = <0,449,800,899>;
  }

  // This method is called by 'HorizontalList' every time the list loads or updates \
  // an item.
  $rect <440,530,640,570>
  slot OnLoadItem
  {
    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = HorizontalList.Item;
    var Views::Text itemView = (Views::Text)HorizontalList.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( itemView == null )
      return;


    array string myItem[5];
    myItem[0] = "없음";
    myItem[1] = "3s";
    myItem[2] = "5s";
    myItem[3] = "10s";
    myItem[4] = "15s";

    // Configure the item view ...
    itemView.String = myItem[itemNo];
    itemView.Font   = Application::MyFont2;
    itemView.Color  = #FFFFFFFF;

    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    itemView.Bounds.size = point( HorizontalList.ItemWidth, HorizontalList.Bounds.h );
  }

  // This method is called by 'HorizontalList' every time the list loads or updates \
  // an item.
  $rect <440,570,640,610>
  slot OnLoadItem1
  {
    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = HorizontalList1.Item;
    var Views::Text itemView = (Views::Text)HorizontalList1.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( itemView == null )
      return;

    array string myItem[4];
    myItem[0] = "48MP";
    myItem[1] = "12MP";

    // Configure the item view ...
    itemView.String = myItem[itemNo];
    itemView.Font   = Resources::FontMedium;
    itemView.Color  = #FFFFFFFF;


    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    itemView.Bounds.size = point( HorizontalList1.ItemWidth, HorizontalList.Bounds.h );
  }
}

$rect <1119,540,1319,580>
$output false
class RateSetting : Core::Group
{
  $rect <10,480,210,520>
  inherited property Bounds = <0,0,800,450>;

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,0,800,450>;
    preset Color = #22222298;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle1
  {
    preset Bounds = <0,250,800,450>;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Core::WipeTouchHandler WipeTouchHandler
  {
    preset Bounds = <0,0,800,297>;
    preset OnBottom = EnterSettingSpec;
  }

  $rect <20,20,160,60>
  object Views::Line Line
  {
    preset Point2 = <450,266>;
    preset Point1 = <350,266>;
    preset Width = 5;
  }

  $rect <250,480,450,520>
  slot EnterSettingSpec
  {
    if(Owner != null)
      Owner.DismissDialog( this, Effects::SlideDownCentered, null, null, null, null, false );
  }

  $rect <20,20,160,60>
  object Core::HorizontalList HorizontalList
  {
    preset Bounds = <0,350,800,450>;
    preset Focus = null;
    preset OnUpdate = SetTime;
    preset OnLoadItem = OnLoadItem;
    preset PaddingRight = 330;
    preset SlideHandler = SlideTouchHandler;
    preset ScrollOffset = 0;
    preset SelectedItem = 0;
    preset PaddingLeft = 320;
    preset ItemWidth = 150;
    preset NoOfItems = 9;
    preset ItemClass = Views::Text;
  }

  // This method is called by 'HorizontalList' every time the list loads or updates \
  // an item.
  $rect <250,520,450,560>
  slot OnLoadItem
  {
    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = HorizontalList.Item;
    var Views::Text itemView = (Views::Text)HorizontalList.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( itemView == null )
      return;


    array string myItem[9];
    myItem[0] = "3p/1s";
    myItem[1] = "5p/1s";
    myItem[2] = "10p/1s";
    myItem[3] = "15p/1s";
    myItem[4] = "30p/1s";
    myItem[5] = "10p/3s";
    myItem[6] = "30p/3s";
    myItem[7] = "30p/6s";
    myItem[8] = "30p/10s";

    // Configure the item view ...
    itemView.String = myItem[itemNo];
    itemView.Font   = Application::MyFont2;
    itemView.Color  = #FFFFFFFF;

    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    itemView.Bounds.size = point( HorizontalList.ItemWidth, HorizontalList.Bounds.h );
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <274,297,526,338>;
    preset String = "연사";
    preset Font = Application::MyFont;
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler
  {
    preset Bounds = <0,350,800,450>;
    preset SnapNext = <150,0>;
  }

  $rect <249,560,449,600>
  slot SetTime
  {
    var int32 centerPosition = 400;

    var int32 i;

    for (i = 0; i < HorizontalList.NoOfItems; i++){
      var Views::Text itemView = (Views::Text)HorizontalList.GetViewForItem(i);

      if (itemView != null){
          var int32 itemCenter = itemView.Bounds.x1 + (itemView.Bounds.w / 2);

          var int32 distanceFromCenter = itemCenter - centerPosition;

          if (distanceFromCenter >= -20 && distanceFromCenter <= 20){
              itemView.Color = #77CCFFFF;
              
              Application::Device.BurstRate = i;
          }
          else{
              itemView.Color = #FFFFFFFF;
          }
      }
    }
  }
}

$rect <1509,480,1709,520>
$output false
resource Resources::Bitmap rectbtnBlue
{
  attr bitmapfile FileName = .\Res\BlueRectBtn2 (2) (1).png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1749,400,1949,440>
$output false
resource Resources::Font MyFontBold
{
  attr fontname FontName = Source Sans Pro Black;
  attr fontheight Height = 20;
  attr fontheightmode HeightMode = Popular;
  attr fontquality Quality = High;
  attr fontranges Ranges = 0x20-0xFF, 0xac00-0xd7a3;
  attr fontaspectratio AspectRatio = 1.0;
  attr fontbold Bold = false;
  attr fontitalic Italic = false;
  attr fontkerning Kerning = true;
  attr fontrowdistance RowDistance;
}

$rect <849,371,1049,411>
$output false
class ConnectSetting : Core::Group
{
  $rect <20,20,160,60>
  object Core::WipeTouchHandler WipeTouchHandler
  {
    preset Bounds = <0,0,800,450>;
    preset OnTop = quit;
  }

  $rect <0,520,200,560>
  inherited property Bounds = <0,0,800,450>;

  $rect <240,520,440,560>
  slot quit
  {
    if(Owner != null)
      Owner.DismissDialog( this, Effects::SlideRightCentered, null, null, null, null, false );
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,0,800,450>;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton4
  {
    preset Bounds = <0,0,75,71>;
    preset OnLeave = quit;
    preset Label = "";
    preset Appearance = Application::PushButtonConfig;
  }

  $rect <20,20,160,60>
  object Views::Line Line2
  {
    preset Point2 = <22,37>;
    preset Point1 = <38,24>;
    preset Width = 5;
  }

  $rect <20,20,160,60>
  object Views::Line Line3
  {
    preset Point2 = <38,50>;
    preset Point1 = <22,37>;
    preset Width = 5;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <0,86,800,178>;
    preset OnPress = Slot1;
    preset Icon = Application::longbtn;
    preset Label = "기기 연결";
    preset Appearance = Application::PushButtonConfig1;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton1
  {
    preset Bounds = <0,173,800,265>;
    preset OnPress = Slot2;
    preset Icon = Application::longbtn;
    preset Label = "라이브 스트리밍";
    preset Appearance = Application::PushButtonConfig1;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <352,0,452,71>;
    preset String = "연결";
    preset Font = Application::MyFont;
  }

  $rect <20,20,160,60>
  object Application::ConnectLiveStreaming ConnectLiveStreaming
  {
    preset Bounds = <800,0,1600,450>;
  }

  $rect <20,20,160,60>
  object Application::ConnectDevice ConnectDevice
  {
    preset Bounds = <800,0,1600,450>;
  }

  $rect <491,520,691,560>
  slot Slot1
  {
    PresentDialog( ConnectDevice, null, null, null, null, null, null, null, null, false );
  }

  $rect <490,560,690,600>
  slot Slot2
  {
    PresentDialog( ConnectLiveStreaming, null, null, null, null, null, null, null, null, false );
  }

  $reorder WipeTouchHandler 101
}

$rect <849,262,1049,302>
$output false
class LockedScreen : Core::Group
{
  $rect <0,520,200,560>
  inherited property Bounds = <0,0,800,450>;

  $rect <20,20,160,60>
  object Views::Image Image1
  {
    preset Bounds = <549,20,639,112>;
    preset Bitmap = Application::MiniLockImage;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,0,800,450>;
    preset Color = #00000091;
  }

  $rect <20,20,160,60>
  object Views::Line Line
  {
    preset Point2 = <450,440>;
    preset Point1 = <350,440>;
    preset Width = 5;
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Bounds = <310,95,491,279>;
    preset Bitmap = Application::LockImage;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <310,279,491,358>;
    preset String = "위로 밀어 잠금해제";
    preset Font = Application::MyFont2;
  }

  $rect <0,560,200,600>
  slot EnterMainView
  {
    if(Owner != null)
      Owner.DismissDialog( this, Effects::SlideUpCentered, null, null, null, null, false );

    Application::Device.ScreenLock = false;
  }

  $rect <20,20,160,60>
  object Core::WipeTouchHandler WipeTouchHandler
  {
    preset Bounds = <0,0,800,450>;
    preset OnEnd = RestartTimer;
    preset OnTop = EnterMainView;
    preset OnStart = VisibleTrue;
  }

  $rect <260,520,460,560>
  object Core::Timer Timer
  {
    preset OnTrigger = VisibleFalse;
    preset Period = 3000;
    preset Begin = 0;
    preset Enabled = false;
  }

  $rect <260,560,460,600>
  slot RestartTimer
  {
    Timer.Enabled = false;
    Timer.Enabled = true;
  }

  $rect <540,560,740,600>
  slot VisibleFalse
  {
    Image.Visible = false;
    Line.Visible = false;
    Rectangle.Visible = false;
    Text.Visible = false;
  }

  $rect <540,520,740,560>
  slot VisibleTrue
  {
    Image.Visible = true;
    Line.Visible = true;
    Rectangle.Visible = true;
    Text.Visible = true;
  }
}

$rect <1509,600,1709,640>
$output false
resource Resources::Bitmap LockImage
{
  attr bitmapfile FileName = .\Res\lock.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <1509,640,1709,680>
$output false
resource Resources::Bitmap MiniLockImage
{
  attr bitmapfile FileName = .\Res\minilock.png;
  attr bitmapformat Format = Native;
  attr framesize FrameSize;
  attr framedelay FrameDelay;
  attr bitmapdithering Dithering = Auto;
  attr bitmapmode Mode = Default;
}

$rect <849,331,1049,371>
$output false
class DisplaySetting : Core::Group
{
  $rect <20,20,160,60>
  object Core::WipeTouchHandler WipeTouchHandler
  {
    preset Bounds = <0,0,800,450>;
    preset OnTop = quit;
  }

  $rect <0,520,200,560>
  inherited property Bounds = <0,0,800,450>;

  $rect <240,520,440,560>
  slot quit
  {
    if(Owner != null)
      Owner.DismissDialog( this, Effects::SlideRightCentered, null, null, null, null, false );
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,0,800,450>;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton4
  {
    preset Bounds = <0,0,75,71>;
    preset OnLeave = quit;
    preset Label = "";
    preset Appearance = Application::PushButtonConfig;
  }

  $rect <20,20,160,60>
  object Views::Line Line2
  {
    preset Point2 = <22,37>;
    preset Point1 = <38,24>;
    preset Width = 5;
  }

  $rect <20,20,160,60>
  object Views::Line Line3
  {
    preset Point2 = <38,50>;
    preset Point1 = <22,37>;
    preset Width = 5;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <310,0,494,71>;
    preset String = "디스플레이";
    preset Font = Application::MyFont;
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler
  {
    preset Bounds = <0,71,800,449>;
    preset RetargetCondition = Core::RetargetReason[ForeignPress, LongPress];
  }

  $rect <20,20,160,60>
  object Core::VerticalList VerticalList
  {
    preset Bounds = <0,71,800,450>;
    preset OnLoadItem = OnLoadItem;
    preset SlideHandler = SlideTouchHandler;
    preset ItemHeight = 90;
    preset NoOfItems = 6;
    preset ItemClass = Application::BtnToggleBtn;
  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <240,570,440,610>
  slot OnLoadItem
  {
    var int32       itemNo   = VerticalList.Item;
    var Application::BtnToggleBtn itemView = (Application::BtnToggleBtn)VerticalList.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( itemView == null )
      return;

    array string str[6];
    str[0] = "밝기";
    str[1] = "방향 잠금";
    str[2] = "화면 잠금";
    str[3] = "절전 모드";
    str[4] = "전면 스크린";
    str[5] = "그리드 설정";
    // Configure the item view ...
    itemView.PushButton.Label = str[itemNo];

    if(itemNo == 0)
    switch(itemNo){
      case 0: {
        itemView.ToggleButton.Visible = false;
        itemView.PushButton.OnPress = Brightness;
      }
      case 1: {
        itemView.ToggleButton.Enabled = true;
      }
      default:{
        itemView.ToggleButton.Enabled = true;
      }
    }

    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    itemView.Bounds.size = point( VerticalList.Bounds.w, VerticalList.ItemHeight );
  }

  $rect <510,520,710,560>
  slot Brightness
  {
    PresentDialog( DisplayBrightness, null, null, null, null, null, null, null, null, false );
    DisplayBrightness.HorizontalList.ScrollOffset = -50 * Application::Device.Brightness;
  }

  $rect <20,20,160,60>
  object Application::DisplayBrightness DisplayBrightness
  {
    preset Bounds = <800,-1,1600,449>;
  }

  $reorder WipeTouchHandler 101
}

$rect <849,451,1049,491>
$output false
class SystemSetting : Core::Group
{
  $rect <20,20,160,60>
  object Core::WipeTouchHandler WipeTouchHandler
  {
    preset Bounds = <0,0,800,450>;
    preset OnTop = quit;
  }

  $rect <0,520,200,560>
  inherited property Bounds = <0,0,800,450>;

  $rect <240,520,440,560>
  slot quit
  {
    if(Owner != null)
      Owner.DismissDialog( this, Effects::SlideRightCentered, null, null, null, null, false );
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,0,800,450>;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton4
  {
    preset Bounds = <0,0,75,71>;
    preset OnLeave = quit;
    preset Label = "";
    preset Appearance = Application::PushButtonConfig;
  }

  $rect <20,20,160,60>
  object Views::Line Line2
  {
    preset Point2 = <22,37>;
    preset Point1 = <38,24>;
    preset Width = 5;
  }

  $rect <20,20,160,60>
  object Views::Line Line3
  {
    preset Point2 = <38,50>;
    preset Point1 = <22,37>;
    preset Width = 5;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <352,0,452,71>;
    preset String = "시스템";
    preset Font = Application::MyFont;
  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <240,560,440,600>
  slot OnLoadItem
  {
    var int32       itemNo   = VerticalList.Item;
    var Application::BtnToggleBtn itemView = (Application::BtnToggleBtn)VerticalList.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( itemView == null )
      return;

    array string str[5];
    str[0] = "자동 전원 꺼짐";
    str[1] = "언어";
    str[2] = "날짜/시간";
    str[3] = "알림음";
    str[4] = "시스템 초기화";
    // Configure the item view ...
    itemView.PushButton.Label = str[itemNo];

    switch(itemNo){
      case 0:{
        itemView.ToggleButton.Visible = false;
        itemView.PushButton.OnPress = AutoPowerOff;
      }
      case 1:{
        itemView.ToggleButton.Visible = false;
        itemView.PushButton.OnPress = Language;
      }
      case 2:{
        itemView.ToggleButton.Visible = false;
        itemView.PushButton.OnPress = Time;
      }
      case 4:{
        itemView.ToggleButton.Visible = false;
        itemView.PushButton.OnPress = Reset;
      }
      case 3: itemView.ToggleButton.Enabled = true;
      default: ;
    }

    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    itemView.Bounds.size = point( VerticalList.Bounds.w, VerticalList.ItemHeight );
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler
  {
    preset Bounds = <0,71,800,450>;
  }

  $rect <20,20,160,60>
  object Core::VerticalList VerticalList
  {
    preset Bounds = <0,70,800,450>;
    preset OnLoadItem = OnLoadItem;
    preset SlideHandler = SlideTouchHandler;
    preset ItemHeight = 90;
    preset NoOfItems = 5;
    preset ItemClass = Application::BtnToggleBtn;
  }

  $rect <20,20,160,60>
  object Application::SystemAutoPowerOff SystemAutoPowerOff
  {
    preset Bounds = <800,0,1600,450>;
  }

  $rect <20,20,160,60>
  object Application::SystemLanguage SystemLanguage
  {
    preset Bounds = <800,0,1600,450>;
  }

  $rect <20,20,160,60>
  object Application::SystemReset SystemReset
  {
    preset Bounds = <800,0,1600,450>;
  }

  $rect <20,20,160,60>
  object Application::SystemTime SystemTime
  {
    preset Bounds = <800,0,1600,450>;
  }

  $rect <490,520,690,560>
  slot AutoPowerOff
  {
    PresentDialog( SystemAutoPowerOff, null, null, null, null, null, null, null, null, false );
    DisplayBrightness.HorizontalList.ScrollOffset = -100 * Application::Device.AutoPowerOff;
  }

  $rect <490,560,690,600>
  slot Language
  {
    PresentDialog( Language, null, null, null, null, null, null, null, null, false );
    DisplayBrightness.HorizontalList.ScrollOffset = -100 * Application::Device.Language;
  }

  $rect <490,600,690,640>
  slot Time
  {
    PresentDialog( SystemTime, null, null, null, null, null, null, null, null, false );
    DisplayBrightness.HorizontalList.ScrollOffset = -50 * Application::Device.Month;
  }

  $rect <490,640,690,680>
  slot Reset
  {
    PresentDialog( SystemReset, null, null, null, null, null, null, null, null, false );
  }

  $reorder WipeTouchHandler 101
}

$rect <849,411,1049,451>
$output false
class RecordSetting : Core::Group
{
  $rect <20,20,160,60>
  object Core::WipeTouchHandler WipeTouchHandler
  {
    preset Bounds = <0,0,800,450>;
    preset OnTop = quit;
  }

  $rect <0,520,200,560>
  inherited property Bounds = <0,0,800,450>;

  $rect <240,520,440,560>
  slot quit
  {
    if(Owner != null)
      Owner.DismissDialog( this, Effects::SlideRightCentered, null, null, null, null, false );
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,0,800,450>;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton4
  {
    preset Bounds = <0,0,75,71>;
    preset OnLeave = quit;
    preset Label = "";
    preset Appearance = Application::PushButtonConfig;
  }

  $rect <20,20,160,60>
  object Views::Line Line2
  {
    preset Point2 = <22,37>;
    preset Point1 = <38,24>;
    preset Width = 5;
  }

  $rect <20,20,160,60>
  object Views::Line Line3
  {
    preset Point2 = <38,50>;
    preset Point1 = <22,37>;
    preset Width = 5;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <22,86,783,178>;
    preset Icon = Application::longbtn;
    preset Label = "     기기 연결";
    preset Appearance = Application::PushButtonConfig1;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton1
  {
    preset Bounds = <22,173,783,265>;
    preset Icon = Application::longbtn;
    preset Label = "     라이브 스트리밍";
    preset Appearance = Application::PushButtonConfig1;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <352,0,452,71>;
    preset String = "촬영";
    preset Font = Application::MyFont;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton2
  {
    preset Bounds = <0,86,800,178>;
    preset Icon = Application::longbtn;
    preset Label = "퀵캡쳐";
    preset Appearance = Application::PushButtonConfig1;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton3
  {
    preset Bounds = <0,173,800,265>;
    preset Icon = Application::longbtn;
    preset Label = "촬영 표시등";
    preset Appearance = Application::PushButtonConfig1;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton5
  {
    preset Bounds = <0,261,800,353>;
    preset Icon = Application::longbtn;
    preset Label = "마이크 설정";
    preset Appearance = Application::PushButtonConfig1;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton6
  {
    preset Bounds = <0,348,800,440>;
    preset Icon = Application::longbtn;
    preset Label = "외장 마이크 볼륨";
    preset Appearance = Application::PushButtonConfig1;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton ToggleButton
  {
    preset Bounds = <680,107,754,157>;
    preset Outlet = ^Application::Device.QuickCapture;
    preset Label = "";
    preset Appearance = WidgetSet::Switch_Medium;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton ToggleButton1
  {
    preset Bounds = <680,194,754,244>;
    preset Label = "";
    preset Appearance = WidgetSet::Switch_Medium;
  }

  $reorder WipeTouchHandler 101
}

$rect <849,520,1049,560>
$output false
class BtnToggleBtn : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,800,90>;

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <25,10,775,80>;
    preset Icon = Application::longbtn;
    preset Label = "Caption";
    preset Appearance = Application::PushButtonConfig1;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton ToggleButton
  {
    preset Bounds = <675,20,750,70>;
    preset Label = "Caption";
    preset Appearance = WidgetSet::Switch_Medium;
  }
}

$rect <849,589,1049,629>
$output false
class DisplayBrightness : Core::Group
{
  $rect <0,520,200,560>
  inherited property Bounds = <0,0,800,450>;

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,0,800,450>;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Line Line2
  {
    preset Point2 = <22,37>;
    preset Point1 = <38,24>;
    preset Width = 5;
  }

  $rect <20,20,160,60>
  object Views::Line Line3
  {
    preset Point2 = <38,50>;
    preset Point1 = <22,37>;
    preset Width = 5;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <310,0,494,71>;
    preset String = "밝기";
    preset Font = Application::MyFont;
  }

  // This method is called by 'HorizontalList' every time the list loads or updates \
  // an item.
  $rect <460,520,660,560>
  slot OnLoadItem
  {
    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = HorizontalList.Item;
    var Views::Text itemView = (Views::Text)HorizontalList.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( itemView == null )
      return;


    // Configure the item view ...
    itemView.String = itemNo;
    itemView.Font   = Resources::FontMedium;
    itemView.Color  = #FFFFFFFF;


    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    itemView.Bounds.size = point( HorizontalList.ItemWidth, HorizontalList.Bounds.h );
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler
  {
    preset Bounds = <0,128,800,225>;
    preset SnapNext = <50,0>;
  }

  $rect <20,20,160,60>
  object Core::HorizontalList HorizontalList
  {
    preset Bounds = <0,128,800,225>;
    preset Focus = null;
    preset OnUpdate = SetBrightness;
    preset OnLoadItem = OnLoadItem;
    preset PaddingRight = 375;
    preset SlideHandler = SlideTouchHandler;
    preset ScrollOffset = -4950;
    preset SelectedItem = 0;
    preset PaddingLeft = 375;
    preset ItemWidth = 50;
    preset NoOfItems = 101;
    preset ItemClass = Views::Text;
  }

  $rect <460,560,660,600>
  slot SetBrightness
  {
    var int32 centerPosition = 400;

    var int32 i;

    for (i = 0; i < HorizontalList.NoOfItems; i++){
      var Views::Text itemView = (Views::Text)HorizontalList.GetViewForItem(i);

      // 아이템이 현재 화면에 보이는 경우에만
      if (itemView != null){
          // 아이템의 현재 위치 계산 (아이템의 왼쪽 상단 X좌표 + 아이템 너비 / 2)
          var int32 itemCenter = itemView.Bounds.x1 + (itemView.Bounds.w / 2);

          // 중앙 위치와 아이템 중심 위치의 차이 계산
          var int32 distanceFromCenter = itemCenter - centerPosition;

          // 중앙에 가까운 아이템은 색상을 하늘색으로, 나머지는 하얀색으로
          if (distanceFromCenter >= -20 && distanceFromCenter <= 20){
              itemView.Color = #77CCFFFF;  // 하늘색
              Application::Device.Brightness = i+1;
          }
          else{
              itemView.Color = #FFFFFFFF;  // 기본 하얀색
          }
      }
    }
  }

  $rect <240,520,440,560>
  slot quit
  {
    if(Owner != null)
      Owner.DismissDialog( this, Effects::SlideRightCentered, null, null, null, null, false );
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton4
  {
    preset Bounds = <0,0,75,71>;
    preset OnLeave = quit;
    preset Label = "";
    preset Appearance = Application::PushButtonConfig;
  }
}

$rect <849,860,1049,900>
$output false
class SystemAutoPowerOff : Core::Group
{
  $rect <0,520,200,560>
  inherited property Bounds = <0,0,800,450>;

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,0,800,450>;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Line Line2
  {
    preset Point2 = <22,37>;
    preset Point1 = <38,24>;
    preset Width = 5;
  }

  $rect <20,20,160,60>
  object Views::Line Line3
  {
    preset Point2 = <38,50>;
    preset Point1 = <22,37>;
    preset Width = 5;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <310,0,494,71>;
    preset String = "자동 전원 꺼짐";
    preset Font = Application::MyFont;
  }

  // This method is called by 'HorizontalList' every time the list loads or updates \
  // an item.
  $rect <460,520,660,560>
  slot OnLoadItem
  {
    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = HorizontalList.Item;
    var Views::Text itemView = (Views::Text)HorizontalList.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( itemView == null )
      return;

    array string myitem[4];
    myitem[0] = "3m";
    myitem[1] = "5m";
    myitem[2] = "15m";
    myitem[3] = "계속 켜짐";


    // Configure the item view ...
    itemView.String = myitem[itemNo];
    itemView.Font   = Application::MyFont2;
    itemView.Color  = #FFFFFFFF;


    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    itemView.Bounds.size = point( HorizontalList.ItemWidth, HorizontalList.Bounds.h );
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler
  {
    preset Bounds = <0,128,800,225>;
    preset SnapNext = <50,0>;
  }

  $rect <20,20,160,60>
  object Core::HorizontalList HorizontalList
  {
    preset Bounds = <0,128,800,225>;
    preset Focus = null;
    preset OnUpdate = SetAutoPowerOff;
    preset OnLoadItem = OnLoadItem;
    preset PaddingRight = 350;
    preset SlideHandler = SlideTouchHandler;
    preset ScrollOffset = 0;
    preset SelectedItem = 0;
    preset PaddingLeft = 350;
    preset ItemWidth = 100;
    preset NoOfItems = 4;
    preset ItemClass = Views::Text;
  }

  $rect <460,560,660,600>
  slot SetAutoPowerOff
  {
    var int32 centerPosition = 400;

    var int32 i;

    for (i = 0; i < HorizontalList.NoOfItems; i++){
      var Views::Text itemView = (Views::Text)HorizontalList.GetViewForItem(i);

      // 아이템이 현재 화면에 보이는 경우에만
      if (itemView != null){
          // 아이템의 현재 위치 계산 (아이템의 왼쪽 상단 X좌표 + 아이템 너비 / 2)
          var int32 itemCenter = itemView.Bounds.x1 + (itemView.Bounds.w / 2);

          // 중앙 위치와 아이템 중심 위치의 차이 계산
          var int32 distanceFromCenter = itemCenter - centerPosition;

          // 중앙에 가까운 아이템은 색상을 하늘색으로, 나머지는 하얀색으로
          if (distanceFromCenter >= -20 && distanceFromCenter <= 20){
              itemView.Color = #77CCFFFF;  // 하늘색
              Application::Device.AutoPowerOff = i;
          }
          else{
              itemView.Color = #FFFFFFFF;  // 기본 하얀색
          }
      }
    }
  }

  $rect <240,520,440,560>
  slot quit
  {
    if(Owner != null)
      Owner.DismissDialog( this, Effects::SlideRightCentered, null, null, null, null, false );
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton4
  {
    preset Bounds = <0,0,75,71>;
    preset OnLeave = quit;
    preset Label = "";
    preset Appearance = Application::PushButtonConfig;
  }
}

$rect <849,900,1049,940>
$output false
class SystemLanguage : Core::Group
{
  $rect <0,520,200,560>
  inherited property Bounds = <0,0,800,450>;

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,0,800,450>;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Line Line2
  {
    preset Point2 = <22,37>;
    preset Point1 = <38,24>;
    preset Width = 5;
  }

  $rect <20,20,160,60>
  object Views::Line Line3
  {
    preset Point2 = <38,50>;
    preset Point1 = <22,37>;
    preset Width = 5;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <310,0,494,71>;
    preset String = "언어";
    preset Font = Application::MyFont;
  }

  // This method is called by 'HorizontalList' every time the list loads or updates \
  // an item.
  $rect <460,520,660,560>
  slot OnLoadItem
  {
    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = HorizontalList.Item;
    var Views::Text itemView = (Views::Text)HorizontalList.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( itemView == null )
      return;

    array string myitem[2];
    myitem[0] = "한국어";
    myitem[1] = "영어";

    // Configure the item view ...
    itemView.String = myitem[itemNo];
    itemView.Font   = Application::MyFont2;
    itemView.Color  = #FFFFFFFF;


    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    itemView.Bounds.size = point( HorizontalList.ItemWidth, HorizontalList.Bounds.h );
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler
  {
    preset Bounds = <0,128,800,225>;
    preset SnapNext = <50,0>;
  }

  $rect <20,20,160,60>
  object Core::HorizontalList HorizontalList
  {
    preset Bounds = <0,128,800,225>;
    preset Focus = null;
    preset OnUpdate = SetLanguage;
    preset OnLoadItem = OnLoadItem;
    preset PaddingRight = 350;
    preset SlideHandler = SlideTouchHandler;
    preset ScrollOffset = 0;
    preset SelectedItem = 0;
    preset PaddingLeft = 350;
    preset ItemWidth = 100;
    preset NoOfItems = 2;
    preset ItemClass = Views::Text;
  }

  $rect <460,560,660,600>
  slot SetLanguage
  {
    var int32 centerPosition = 400;

    var int32 i;

    for (i = 0; i < HorizontalList.NoOfItems; i++){
      var Views::Text itemView = (Views::Text)HorizontalList.GetViewForItem(i);

      // 아이템이 현재 화면에 보이는 경우에만
      if (itemView != null){
          // 아이템의 현재 위치 계산 (아이템의 왼쪽 상단 X좌표 + 아이템 너비 / 2)
          var int32 itemCenter = itemView.Bounds.x1 + (itemView.Bounds.w / 2);

          // 중앙 위치와 아이템 중심 위치의 차이 계산
          var int32 distanceFromCenter = itemCenter - centerPosition;

          // 중앙에 가까운 아이템은 색상을 하늘색으로, 나머지는 하얀색으로
          if (distanceFromCenter >= -20 && distanceFromCenter <= 20){
              itemView.Color = #77CCFFFF;  // 하늘색
              Application::Device.Language = i;
          }
          else{
              itemView.Color = #FFFFFFFF;  // 기본 하얀색
          }
      }
    }
  }

  $rect <240,520,440,560>
  slot quit
  {
    if(Owner != null)
      Owner.DismissDialog( this, Effects::SlideRightCentered, null, null, null, null, false );
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton4
  {
    preset Bounds = <0,0,75,71>;
    preset OnLeave = quit;
    preset Label = "";
    preset Appearance = Application::PushButtonConfig;
  }
}

$rect <849,940,1049,980>
$output false
class SystemTime : Core::Group
{
  $rect <0,520,200,560>
  inherited property Bounds = <0,0,800,450>;

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,0,800,450>;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Line Line2
  {
    preset Point2 = <22,37>;
    preset Point1 = <38,24>;
    preset Width = 5;
  }

  $rect <20,20,160,60>
  object Views::Line Line3
  {
    preset Point2 = <38,50>;
    preset Point1 = <22,37>;
    preset Width = 5;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <310,0,494,71>;
    preset String = "날짜/시간";
    preset Font = Application::MyFont;
  }

  $rect <0,640,200,680>
  slot SetMonth
  {
    var int32 centerPosition = 125;

    var int32 i;

    for (i = 0; i < VerticalList.NoOfItems; i++){
      var Views::Text itemView = (Views::Text)VerticalList.GetViewForItem(i);

      // 아이템이 현재 화면에 보이는 경우에만
      if (itemView != null){
          // 아이템의 현재 위치 계산 (아이템의 왼쪽 상단 X좌표 + 아이템 너비 / 2)
          var int32 itemCenter = itemView.Bounds.y1 + (itemView.Bounds.h / 2);

          // 중앙 위치와 아이템 중심 위치의 차이 계산
          var int32 distanceFromCenter = itemCenter - centerPosition;

          // 중앙에 가까운 아이템은 색상을 하늘색으로, 나머지는 하얀색으로
          if (distanceFromCenter >= -20 && distanceFromCenter <= 20){
              itemView.Color = #77CCFFFF;  // 하늘색
              Application::Device.Month = i;
          }
          else{
              itemView.Color = #FFFFFFFF;  // 기본 하얀색
          }
      }
    }
  }

  $rect <240,520,440,560>
  slot quit
  {
    if(Owner != null)
      Owner.DismissDialog( this, Effects::SlideRightCentered, null, null, null, null, false );
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton4
  {
    preset Bounds = <0,0,75,71>;
    preset OnLeave = quit;
    preset Label = "";
    preset Appearance = Application::PushButtonConfig;
  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <0,600,200,640>
  slot OnLoadItem
  {
    /*

      Hint:

      - The code below demonstrates a simple usage of the list component.

      - The list component creates and manages automatically view item instances of
        the class specified in its property 'ItemClass'. In this example it is the
        class 'Views::Text'.

      - When you change the 'ItemClass' property you will also need to replace
        accordingly all 'Views::Text' occurrences in the below code.

      - You will also need to adapt the initialization of the 'itemView'.

    */

    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = VerticalList.Item;
    var Views::Text itemView = (Views::Text)VerticalList.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( itemView == null )
      return;

    // Configure the item view ...
    itemView.String = string( itemNo+1 ) + "월";
    itemView.Font   = Application::MyFont2;
    itemView.Color  = #FFFFFFFF;

    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    itemView.Bounds.size = point( VerticalList.Bounds.w, VerticalList.ItemHeight );
  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <210,600,410,640>
  slot OnLoadItem1
  {
    /*

      Hint:

      - The code below demonstrates a simple usage of the list component.

      - The list component creates and manages automatically view item instances of
        the class specified in its property 'ItemClass'. In this example it is the
        class 'Views::Text'.

      - When you change the 'ItemClass' property you will also need to replace
        accordingly all 'Views::Text' occurrences in the below code.

      - You will also need to adapt the initialization of the 'itemView'.

    */

    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = VerticalList1.Item;
    var Views::Text itemView = (Views::Text)VerticalList1.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( itemView == null )
      return;

    // Configure the item view ...
    itemView.String = string( itemNo+1 ) + "일";
    itemView.Font   = Application::MyFont2;
    itemView.Color  = #FFFFFFFF;

    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    itemView.Bounds.size = point( VerticalList1.Bounds.w, VerticalList1.ItemHeight );
  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <420,600,620,640>
  slot OnLoadItem2
  {
    /*

      Hint:

      - The code below demonstrates a simple usage of the list component.

      - The list component creates and manages automatically view item instances of
        the class specified in its property 'ItemClass'. In this example it is the
        class 'Views::Text'.

      - When you change the 'ItemClass' property you will also need to replace
        accordingly all 'Views::Text' occurrences in the below code.

      - You will also need to adapt the initialization of the 'itemView'.

    */

    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = VerticalList2.Item;
    var Views::Text itemView = (Views::Text)VerticalList2.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( itemView == null )
      return;

    // Configure the item view ...
    itemView.String = string( itemNo+2000 ) + "년";
    itemView.Font   = Application::MyFont2;
    itemView.Color  = #FFFFFFFF;

    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    itemView.Bounds.size = point( VerticalList2.Bounds.w, VerticalList2.ItemHeight );
  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <630,600,830,640>
  slot OnLoadItem3
  {
    /*

      Hint:

      - The code below demonstrates a simple usage of the list component.

      - The list component creates and manages automatically view item instances of
        the class specified in its property 'ItemClass'. In this example it is the
        class 'Views::Text'.

      - When you change the 'ItemClass' property you will also need to replace
        accordingly all 'Views::Text' occurrences in the below code.

      - You will also need to adapt the initialization of the 'itemView'.

    */

    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = VerticalList3.Item;
    var Views::Text itemView = (Views::Text)VerticalList3.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( itemView == null )
      return;

    // Configure the item view ...
    itemView.String = string( itemNo ) + "시";
    itemView.Font   = Application::MyFont2;
    itemView.Color  = #FFFFFFFF;

    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    itemView.Bounds.size = point( VerticalList3.Bounds.w, VerticalList3.ItemHeight );
  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <840,600,1040,640>
  slot OnLoadItem4
  {
    /*

      Hint:

      - The code below demonstrates a simple usage of the list component.

      - The list component creates and manages automatically view item instances of
        the class specified in its property 'ItemClass'. In this example it is the
        class 'Views::Text'.

      - When you change the 'ItemClass' property you will also need to replace
        accordingly all 'Views::Text' occurrences in the below code.

      - You will also need to adapt the initialization of the 'itemView'.

    */

    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = VerticalList4.Item;
    var Views::Text itemView = (Views::Text)VerticalList4.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( itemView == null )
      return;

    // Configure the item view ...
    itemView.String = string( itemNo ) + "분";
    itemView.Font   = Application::MyFont2;
    itemView.Color  = #FFFFFFFF;

    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    itemView.Bounds.size = point( VerticalList4.Bounds.w, VerticalList4.ItemHeight );
  }

  $rect <20,20,160,60>
  object Views::Line Line
  {
    preset Point2 = <434,204>;
    preset Point1 = <75,204>;
  }

  $rect <20,20,160,60>
  object Views::Line Line1
  {
    preset Point2 = <434,250>;
    preset Point1 = <75,250>;
  }

  $rect <20,20,160,60>
  object Views::Line Line4
  {
    preset Point2 = <702,203>;
    preset Point1 = <462,203>;
  }

  $rect <20,20,160,60>
  object Views::Line Line5
  {
    preset Point2 = <702,249>;
    preset Point1 = <462,249>;
  }

  $rect <20,20,160,60>
  object Core::VerticalList VerticalList
  {
    preset Bounds = <75,100,195,350>;
    preset OnUpdate = SetMonth;
    preset OnLoadItem = OnLoadItem;
    preset PaddingBottom = 100;
    preset SlideHandler = SlideTouchHandler;
    preset PaddingTop = 100;
    preset ItemHeight = 50;
    preset NoOfItems = 12;
  }

  $rect <20,20,160,60>
  object Core::VerticalList VerticalList1
  {
    preset Bounds = <195,100,315,350>;
    preset OnUpdate = SetDay;
    preset OnLoadItem = OnLoadItem1;
    preset PaddingBottom = 100;
    preset SlideHandler = SlideTouchHandler1;
    preset PaddingTop = 100;
    preset ItemHeight = 50;
    preset NoOfItems = 31;
  }

  $rect <20,20,160,60>
  object Core::VerticalList VerticalList2
  {
    preset Bounds = <315,100,435,350>;
    preset OnUpdate = SetYear;
    preset OnLoadItem = OnLoadItem2;
    preset PaddingBottom = 100;
    preset SlideHandler = SlideTouchHandler2;
    preset PaddingTop = 100;
    preset ItemHeight = 50;
    preset NoOfItems = 100;
  }

  $rect <20,20,160,60>
  object Core::VerticalList VerticalList3
  {
    preset Bounds = <462,100,582,350>;
    preset OnUpdate = SetHour;
    preset OnLoadItem = OnLoadItem3;
    preset PaddingBottom = 100;
    preset SlideHandler = SlideTouchHandler3;
    preset PaddingTop = 100;
    preset ItemHeight = 50;
    preset NoOfItems = 24;
  }

  $rect <20,20,160,60>
  object Core::VerticalList VerticalList4
  {
    preset Bounds = <582,100,702,350>;
    preset OnUpdate = SetMinute;
    preset OnLoadItem = OnLoadItem4;
    preset PaddingBottom = 100;
    preset SlideHandler = SlideTouchHandler4;
    preset PaddingTop = 100;
    preset ItemHeight = 50;
    preset NoOfItems = 60;
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler
  {
    preset Bounds = <75,100,195,350>;
    preset SnapNext = <0,50>;
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler1
  {
    preset Bounds = <195,100,315,350>;
    preset SnapNext = <0,50>;
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler2
  {
    preset Bounds = <315,100,435,350>;
    preset SnapNext = <0,50>;
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler3
  {
    preset Bounds = <462,100,582,350>;
    preset SnapNext = <0,50>;
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler4
  {
    preset Bounds = <582,100,702,350>;
    preset SnapNext = <0,50>;
  }

  $rect <210,640,410,680>
  slot SetDay
  {
    var int32 centerPosition = 125;

    var int32 i;

    for (i = 0; i < VerticalList1.NoOfItems; i++){
      var Views::Text itemView = (Views::Text)VerticalList1.GetViewForItem(i);

      // 아이템이 현재 화면에 보이는 경우에만
      if (itemView != null){
          // 아이템의 현재 위치 계산 (아이템의 왼쪽 상단 X좌표 + 아이템 너비 / 2)
          var int32 itemCenter = itemView.Bounds.y1 + (itemView.Bounds.h / 2);

          // 중앙 위치와 아이템 중심 위치의 차이 계산
          var int32 distanceFromCenter = itemCenter - centerPosition;

          // 중앙에 가까운 아이템은 색상을 하늘색으로, 나머지는 하얀색으로
          if (distanceFromCenter >= -20 && distanceFromCenter <= 20){
              itemView.Color = #77CCFFFF;  // 하늘색
              Application::Device.Day = i;
          }
          else{
              itemView.Color = #FFFFFFFF;  // 기본 하얀색
          }
      }
    }
  }

  $rect <420,640,620,680>
  slot SetYear
  {
    var int32 centerPosition = 125;

    var int32 i;

    for (i = 0; i < VerticalList2.NoOfItems; i++){
      var Views::Text itemView = (Views::Text)VerticalList2.GetViewForItem(i);

      // 아이템이 현재 화면에 보이는 경우에만
      if (itemView != null){
          // 아이템의 현재 위치 계산 (아이템의 왼쪽 상단 X좌표 + 아이템 너비 / 2)
          var int32 itemCenter = itemView.Bounds.y1 + (itemView.Bounds.h / 2);

          // 중앙 위치와 아이템 중심 위치의 차이 계산
          var int32 distanceFromCenter = itemCenter - centerPosition;

          // 중앙에 가까운 아이템은 색상을 하늘색으로, 나머지는 하얀색으로
          if (distanceFromCenter >= -20 && distanceFromCenter <= 20){
              itemView.Color = #77CCFFFF;  // 하늘색
              Application::Device.Year = i;
          }
          else{
              itemView.Color = #FFFFFFFF;  // 기본 하얀색
          }
      }
    }
  }

  $rect <630,640,830,680>
  slot SetHour
  {
    var int32 centerPosition = 125;

    var int32 i;

    for (i = 0; i < VerticalList3.NoOfItems; i++){
      var Views::Text itemView = (Views::Text)VerticalList3.GetViewForItem(i);

      // 아이템이 현재 화면에 보이는 경우에만
      if (itemView != null){
          // 아이템의 현재 위치 계산 (아이템의 왼쪽 상단 X좌표 + 아이템 너비 / 2)
          var int32 itemCenter = itemView.Bounds.y1 + (itemView.Bounds.h / 2);

          // 중앙 위치와 아이템 중심 위치의 차이 계산
          var int32 distanceFromCenter = itemCenter - centerPosition;

          // 중앙에 가까운 아이템은 색상을 하늘색으로, 나머지는 하얀색으로
          if (distanceFromCenter >= -20 && distanceFromCenter <= 20){
              itemView.Color = #77CCFFFF;  // 하늘색
              Application::Device.Hour = i;
          }
          else{
              itemView.Color = #FFFFFFFF;  // 기본 하얀색
          }
      }
    }
  }

  $rect <840,640,1040,680>
  slot SetMinute
  {
    var int32 centerPosition = 125;

    var int32 i;

    for (i = 0; i < VerticalList4.NoOfItems; i++){
      var Views::Text itemView = (Views::Text)VerticalList4.GetViewForItem(i);

      // 아이템이 현재 화면에 보이는 경우에만
      if (itemView != null){
          // 아이템의 현재 위치 계산 (아이템의 왼쪽 상단 X좌표 + 아이템 너비 / 2)
          var int32 itemCenter = itemView.Bounds.y1 + (itemView.Bounds.h / 2);

          // 중앙 위치와 아이템 중심 위치의 차이 계산
          var int32 distanceFromCenter = itemCenter - centerPosition;

          // 중앙에 가까운 아이템은 색상을 하늘색으로, 나머지는 하얀색으로
          if (distanceFromCenter >= -20 && distanceFromCenter <= 20){
              itemView.Color = #77CCFFFF;  // 하늘색
              Application::Device.Minute = i;
          }
          else{
              itemView.Color = #FFFFFFFF;  // 기본 하얀색
          }
      }
    }
  }
}

$rect <849,980,1049,1020>
$output false
class SystemReset : Core::Group
{
  $rect <0,520,200,560>
  inherited property Bounds = <0,0,800,450>;

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <166,90,635,360>;
    preset Color = #000000FF;
  }

  $rect <240,520,440,560>
  slot quit
  {
    if(Owner != null)
      Owner.DismissDialog( this, null, null, null, null, null, false );
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <271,135,529,225>;
    preset String = "시스템을 초기화하시겠습니까?";
    preset Font = Application::MyFont2;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <236,264,386,314>;
    preset OnPress = Reset;
    preset Icon = Application::longbtn;
    preset Label = "예";
    preset Appearance = Application::PushButtonConfig;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton1
  {
    preset Bounds = <414,264,564,314>;
    preset OnPress = quit;
    preset Icon = Application::longbtn;
    preset Label = "아니오";
    preset Appearance = Application::PushButtonConfig;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle1
  {
    preset Bounds = <166,90,635,360>;
    preset Color = #000000FF;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object Views::Text Text1
  {
    preset Bounds = <271,174,529,264>;
    preset String = "초기화 되었습니다.";
    preset Font = Application::MyFont2;
    preset Visible = false;
  }

  $rect <470,520,670,560>
  slot Reset
  {
    Rectangle1.Visible = true;
    Text1.Visible = true;
    SimpleTouchHandler.Enable = true;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler
  {
    preset Point4 = <0,0>;
    preset Point3 = <800,0>;
    preset Point2 = <800,450>;
    preset Point1 = <0,450>;
    preset OnPress = quit;
    preset Enabled = false;
  }
}

$rect <849,760,1049,800>
$output false
class RecordMic : Core::Group
{
  $rect <20,20,160,60>
  object Core::WipeTouchHandler WipeTouchHandler
  {
    preset Bounds = <0,0,800,450>;
    preset OnTop = quit;
  }

  $rect <0,520,200,560>
  inherited property Bounds = <0,0,800,450>;

  $rect <240,520,440,560>
  slot quit
  {
    if(Owner != null)
      Owner.DismissDialog( this, Effects::SlideRightCentered, null, null, null, null, false );
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,0,800,450>;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton4
  {
    preset Bounds = <0,0,75,71>;
    preset OnLeave = quit;
    preset Label = "";
    preset Appearance = Application::PushButtonConfig;
  }

  $rect <20,20,160,60>
  object Views::Line Line2
  {
    preset Point2 = <22,37>;
    preset Point1 = <38,24>;
    preset Width = 5;
  }

  $rect <20,20,160,60>
  object Views::Line Line3
  {
    preset Point2 = <38,50>;
    preset Point1 = <22,37>;
    preset Width = 5;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <291,0,510,71>;
    preset String = "마이크 설정";
    preset Font = Application::MyFont;
  }

  // This method is called by 'HorizontalList' every time the list loads or updates \
  // an item.
  $rect <460,520,660,560>
  slot OnLoadItem
  {
    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = HorizontalList.Item;
    var Views::Text itemView = (Views::Text)HorizontalList.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( itemView == null )
      return;

    array string myitem[2];
    myitem[0] = "기본";
    myitem[1] = "바람소리 감소";

    // Configure the item view ...
    itemView.String = myitem[itemNo];
    itemView.Font   = Application::MyFont2;
    itemView.Color  = #FFFFFFFF;


    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    itemView.Bounds.size = point( HorizontalList.ItemWidth, HorizontalList.Bounds.h );
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler
  {
    preset Bounds = <0,128,800,225>;
    preset SnapNext = <50,0>;
  }

  $rect <20,20,160,60>
  object Core::HorizontalList HorizontalList
  {
    preset Bounds = <0,128,800,225>;
    preset Focus = null;
    preset OnUpdate = SetMic;
    preset OnLoadItem = OnLoadItem;
    preset PaddingRight = 325;
    preset SlideHandler = SlideTouchHandler;
    preset ScrollOffset = 0;
    preset SelectedItem = 0;
    preset PaddingLeft = 325;
    preset ItemWidth = 150;
    preset NoOfItems = 2;
    preset ItemClass = Views::Text;
  }

  $rect <460,560,660,600>
  slot SetMic
  {
    var int32 centerPosition = 400;

    var int32 i;

    for (i = 0; i < HorizontalList.NoOfItems; i++){
      var Views::Text itemView = (Views::Text)HorizontalList.GetViewForItem(i);

      // 아이템이 현재 화면에 보이는 경우에만
      if (itemView != null){
          // 아이템의 현재 위치 계산 (아이템의 왼쪽 상단 X좌표 + 아이템 너비 / 2)
          var int32 itemCenter = itemView.Bounds.x1 + (itemView.Bounds.w / 2);

          // 중앙 위치와 아이템 중심 위치의 차이 계산
          var int32 distanceFromCenter = itemCenter - centerPosition;

          // 중앙에 가까운 아이템은 색상을 하늘색으로, 나머지는 하얀색으로
          if (distanceFromCenter >= -20 && distanceFromCenter <= 20){
              itemView.Color = #77CCFFFF;  // 하늘색
              Application::Device.Mic = i;
          }
          else{
              itemView.Color = #FFFFFFFF;  // 기본 하얀색
          }
      }
    }
  }

  $reorder WipeTouchHandler 101
}

$rect <849,800,1049,840>
$output false
class RecordExternalMic : Core::Group
{
  $rect <20,20,160,60>
  object Core::WipeTouchHandler WipeTouchHandler
  {
    preset Bounds = <0,0,800,450>;
    preset OnTop = quit;
  }

  $rect <0,520,200,560>
  inherited property Bounds = <0,0,800,450>;

  $rect <240,520,440,560>
  slot quit
  {
    if(Owner != null)
      Owner.DismissDialog( this, Effects::SlideRightCentered, null, null, null, null, false );
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,0,800,450>;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton4
  {
    preset Bounds = <0,0,75,71>;
    preset OnLeave = quit;
    preset Label = "";
    preset Appearance = Application::PushButtonConfig;
  }

  $rect <20,20,160,60>
  object Views::Line Line2
  {
    preset Point2 = <22,37>;
    preset Point1 = <38,24>;
    preset Width = 5;
  }

  $rect <20,20,160,60>
  object Views::Line Line3
  {
    preset Point2 = <38,50>;
    preset Point1 = <22,37>;
    preset Width = 5;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <291,0,510,71>;
    preset String = "외장 마이크 볼륨";
    preset Font = Application::MyFont;
  }

  // This method is called by 'HorizontalList' every time the list loads or updates \
  // an item.
  $rect <460,520,660,560>
  slot OnLoadItem
  {
    // Get the number of the item to load. The list component takes care of the
    // creation of the corresponding item view. Just access it ...
    var int32       itemNo   = HorizontalList.Item;
    var Views::Text itemView = (Views::Text)HorizontalList.View;

    // The implementation of this slot method does not match the item class
    // specified in the associated list component. Or the slot method is not
    // called in context of the OnLoadItem list operation. 
    if ( itemView == null )
      return;

    array string myitem[5];
    myitem[0] = "0%%";
    myitem[1] = "25%%";
    myitem[2] = "50%%";
    myitem[3] = "75%%";
    myitem[4] = "100%%";

    // Configure the item view ...
    itemView.String = myitem[itemNo];
    itemView.Font   = Application::MyFont2;
    itemView.Color  = #FFFFFFFF;


    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    itemView.Bounds.size = point( HorizontalList.ItemWidth, HorizontalList.Bounds.h );
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler
  {
    preset Bounds = <0,128,800,225>;
    preset SnapNext = <50,0>;
  }

  $rect <20,20,160,60>
  object Core::HorizontalList HorizontalList
  {
    preset Bounds = <0,128,800,225>;
    preset Focus = null;
    preset OnUpdate = SetExternalMic;
    preset OnLoadItem = OnLoadItem;
    preset PaddingRight = 325;
    preset SlideHandler = SlideTouchHandler;
    preset ScrollOffset = 0;
    preset SelectedItem = 0;
    preset PaddingLeft = 325;
    preset ItemWidth = 150;
    preset NoOfItems = 5;
    preset ItemClass = Views::Text;
  }

  $rect <460,560,660,600>
  slot SetExternalMic
  {
    var int32 centerPosition = 400;

    var int32 i;

    for (i = 0; i < HorizontalList.NoOfItems; i++){
      var Views::Text itemView = (Views::Text)HorizontalList.GetViewForItem(i);

      // 아이템이 현재 화면에 보이는 경우에만
      if (itemView != null){
          // 아이템의 현재 위치 계산 (아이템의 왼쪽 상단 X좌표 + 아이템 너비 / 2)
          var int32 itemCenter = itemView.Bounds.x1 + (itemView.Bounds.w / 2);

          // 중앙 위치와 아이템 중심 위치의 차이 계산
          var int32 distanceFromCenter = itemCenter - centerPosition;

          // 중앙에 가까운 아이템은 색상을 하늘색으로, 나머지는 하얀색으로
          if (distanceFromCenter >= -20 && distanceFromCenter <= 20){
              itemView.Color = #77CCFFFF;  // 하늘색
              Application::Device.ExternalMic = i;
          }
          else{
              itemView.Color = #FFFFFFFF;  // 기본 하얀색
          }
      }
    }
  }

  $reorder WipeTouchHandler 101
}

$rect <849,649,1049,689>
$output false
class ConnectDevice : Core::Group
{
  $rect <0,520,200,560>
  inherited property Bounds = <0,0,800,450>;

  $rect <240,520,440,560>
  slot quit
  {
    if(Owner != null)
      Owner.DismissDialog( this, null, null, null, null, null, false );
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <190,111,611,339>;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text1
  {
    preset Bounds = <291,167,509,234>;
    preset Alignment = Views::TextAlignment[AlignHorzCenter, AlignVertCenter];
    preset String = "앱에서 Wifi로 연결하세요.";
    preset Font = Application::MyFont2;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler
  {
    preset Point4 = <0,0>;
    preset Point3 = <800,0>;
    preset Point2 = <800,450>;
    preset Point1 = <0,450>;
  }

  $rect <20,20,160,60>
  object WidgetSet::ToggleButton ToggleButton
  {
    preset Bounds = <295,244,505,283>;
    preset Label = "Wifi";
    preset Appearance = WidgetSet::Switch_Medium;
  }
}

$rect <849,689,1049,729>
$output false
class ConnectLiveStreaming : Core::Group
{
  $rect <0,520,200,560>
  inherited property Bounds = <0,0,800,450>;

  $rect <240,520,440,560>
  slot quit
  {
    if(Owner != null)
      Owner.DismissDialog( this, null, null, null, null, null, false );
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <190,111,611,339>;
    preset Color = #000000FF;
  }

  $rect <20,20,160,60>
  object Views::Text Text1
  {
    preset Bounds = <250,192,550,259>;
    preset Alignment = Views::TextAlignment[AlignHorzCenter, AlignVertCenter];
    preset String = "앱에서 정보 등록 후 사용 가능합니다.";
    preset Font = Application::MyFont2;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler
  {
    preset Point4 = <0,0>;
    preset Point3 = <800,0>;
    preset Point2 = <800,450>;
    preset Point1 = <0,450>;
    preset OnPress = quit;
  }
}
